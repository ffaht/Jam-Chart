<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spafford Jam Chart</title>
<style>
:root {
  --bg-color:#000;
  --card-bg:#111;
  --text-color:#f0f0f0;
  --muted-color:#999;
  --border-color:#222;
  --yellow:#ffeb3b;
  --accent-color:#b0b0b0;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:var(--bg-color);color:var(--text-color);min-height:100vh;}
.container{max-width:1200px;margin:0 auto;padding:20px;}
.site-header{text-align:center;padding:2rem 0;margin-bottom:2rem;}
.site-header h1{font-size:2.5rem;margin-bottom:0.5rem;}
.site-header p{color:var(--muted-color);}
.site-disclaimer{font-size:0.85rem;font-style:italic;margin-top:0.5rem;}
.search-container{display:flex;gap:1rem;margin-bottom:2rem;align-items:center;}
#search-input{flex:1;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
#filter-select{padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);}
.search-container input[type="text"]{flex:1;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
.jam-table-container{background:var(--card-bg);border-radius:8px;border:1px solid var(--border-color);overflow-x:auto;}
.jam-table{width:100%;border-collapse:collapse;font-size:0.9rem;}
.jam-table th:first-child,
.jam-table td:first-child{width:95px;min-width:95px;white-space:nowrap;}
.jam-table th{background:#0a0a0a;color:var(--text-color);font-weight:600;padding:1rem 0.75rem;text-align:left;border-bottom:2px solid var(--border-color);cursor:pointer;user-select:none;}
.jam-table th:hover{background:#151515;}
.jam-table td{padding:0.75rem;border-bottom:1px solid var(--border-color);line-height:1.4;vertical-align:top;}
.jam-table tr:hover{background:rgba(255,255,255,0.02);}
.jam-entry{cursor:pointer;color:var(--yellow);}
.jam-entry.highlighted{font-weight:bold;}
.highlighted-row{border-left:4px solid var(--yellow);}
.selected-row{box-shadow:0 0 0 2px rgba(255,235,59,0.3);}
.clickable-filter{cursor:pointer;transition:all 0.2s ease;color:var(--yellow);}
.clickable-filter:hover{text-decoration:underline;color:var(--accent-color);}
.status-message{text-align:center;padding:0.5rem;border-radius:4px;font-weight:bold;}
.status-message.success{color:#28a745;}
.status-message.error{color:#dc3545;}
.status-message.info{color:#17a2b8;}

/* Database Explorer Styles */
.tab-nav{display:flex;gap:0.5rem;margin-bottom:1.5rem;flex-wrap:wrap;}
.tab-button{padding:0.6rem 1.2rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);cursor:pointer;transition:all 0.2s;font-size:0.9rem;}
.tab-button:hover{background:#1a1a1a;}
.tab-button.active{background:#2a2a2a;border-color:var(--yellow);font-weight:600;}
.tab-pane{display:none;}
.tab-pane.active{display:block;}
.mini-stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:1rem;margin-bottom:1.5rem;}
.mini-stat{background:var(--card-bg);padding:1rem;border-radius:6px;border:1px solid var(--border-color);text-align:center;}
.mini-stat-value{font-size:1.8rem;font-weight:bold;color:var(--yellow);}
.mini-stat-label{color:var(--muted-color);font-size:0.85rem;margin-top:0.3rem;}
.input-group{display:flex;gap:0.5rem;margin-bottom:1rem;flex-wrap:wrap;align-items:center;}
.input-group input,.input-group select{flex:1;min-width:200px;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
.btn-search{padding:0.75rem 1.5rem;border-radius:6px;border:none;background:var(--yellow);color:#000;font-weight:600;cursor:pointer;transition:all 0.2s;}
.btn-search:hover{background:#ffd700;}
.result-box{background:#1a1a1a;padding:1.5rem;border-radius:6px;margin-top:1rem;white-space:pre-line;line-height:1.6;}
.page-content{display:block;}

/* Setlist Modal Styles */
.setlist-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.setlist-content {
  background: var(--card-bg);
  border: 2px solid var(--yellow);
  border-radius: 8px;
  padding: 2rem;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
  color: var(--text-color);
}

.setlist-header {
  margin-bottom: 1.5rem;
}

.setlist-date {
  color: var(--text-color);
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
}

.setlist-venue {
  color: var(--muted-color);
  font-size: 1.1rem;
  margin-bottom: 0.25rem;
}

.setlist-show-info {
  color: var(--muted-color);
  font-size: 0.9rem;
  margin-bottom: 1rem;
}

.setlist-section {
  margin-bottom: 1.5rem;
}

.setlist-section-title {
  color: var(--text-color);
  font-weight: bold;
  margin-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 0.25rem;
}

.setlist-songs {
  color: var(--text-color);
  line-height: 1.6;
}

.setlist-song {
  margin-bottom: 0.5rem;
}

.setlist-arrow {
  color: var(--text-color);
  margin: 0 0.25rem;
  font-weight: normal;
}

.setlist-notes {
  color: var(--text-color);
  line-height: 1.6;
  font-style: italic;
  border-left: 3px solid var(--yellow);
  padding-left: 1rem;
  margin-top: 1rem;
}

.setlist-close {
  background: var(--yellow);
  color: #000;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  margin-top: 1rem;
  width: 100%;
}

.setlist-close:hover {
  background: #ffd700;
}

/* Date links in table */
.date-link {
  cursor: pointer;
  text-decoration: none;
  color: var(--text-color) !important;
}

.date-link:hover {
  color: var(--yellow) !important;
}

@media(max-width:768px){.container{padding:15px;}.site-header h1{font-size:2rem;}}
</style>
</head>
<body>
<header class="site-header">
<div class="container">
<h1>Spafford Jam Chart</h1>
<p>😀 😂 😊 😎 😜</p>
<p class="site-disclaimer">Some entries may display as incomplete - working on that!</p>
<div class="tab-nav" style="margin-top:1.5rem;justify-content:center;">
  <button class="tab-button page-tab active" onclick="switchPage('jams')">Jam Chart</button>
  <button class="tab-button page-tab" onclick="switchPage('stats')">Stats</button>
</div>
</div>
</header>
<main class="container">
<div id="page-jams" class="page-content">
<div class="search-container">
<input type="text" id="search-input" placeholder="Search songs, locations, dates..." onkeyup="renderFilteredJams()">
<select id="filter-select" onchange="renderFilteredJams()">
  <option value="all">All Jams</option>
  <option value="highlighted">Highlighted</option>
</select>
</div>
<div class="jam-table-container">
<table class="jam-table">
<thead>
<tr>
<th onclick="sortTable('date')">Date <span id="date-sort">▼</span></th>
<th onclick="sortTable('song')">Song <span id="song-sort"></span></th>
<th onclick="sortTable('timing')">Timing <span id="timing-sort"></span></th>
<th onclick="sortTable('venue')">Location <span id="venue-sort"></span></th>
<th onclick="sortTable('notes')">Notes <span id="notes-sort"></span></th>
</tr>
</thead>
<tbody id="jam-table-body"></tbody>
</table>
</div>
</div>

<div id="page-stats" class="page-content" style="display:none;">
<div style="margin-bottom:2rem;">
  <h2 style="margin-bottom:1.5rem;">Database Stats</h2>
  
  <div class="tab-nav">
    <button class="tab-button active" onclick="switchDbTab('songs')">Song History</button>
    <button class="tab-button" onclick="switchDbTab('pairings')">Song Pairings</button>
    <button class="tab-button" onclick="switchDbTab('locations')">Locations</button>
    <button class="tab-button" onclick="switchDbTab('gaps')">Gap Calculator</button>
  </div>

  <div id="db-songs" class="tab-pane active">
    <div class="mini-stats">
      <div class="mini-stat">
        <div class="mini-stat-value" id="db-total-songs">-</div>
        <div class="mini-stat-label">Unique Songs</div>
      </div>
      <div class="mini-stat">
        <div class="mini-stat-value" id="db-total-shows">-</div>
        <div class="mini-stat-label">Total Shows</div>
      </div>
    </div>
    
    <div class="search-container">
      <input type="text" id="db-song-search" placeholder="Search songs..." onkeyup="filterDbSongs()">
    </div>
    
    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortDbSongs('name')" style="cursor:pointer;">Song <span id="db-songs-sort-name">▲</span></th>
            <th onclick="sortDbSongs('played')" style="cursor:pointer;">Played <span id="db-songs-sort-played"></span></th>
            <th onclick="sortDbSongs('first')" style="cursor:pointer;">First <span id="db-songs-sort-first"></span></th>
            <th onclick="sortDbSongs('last')" style="cursor:pointer;">Last <span id="db-songs-sort-last"></span></th>
            <th onclick="sortDbSongs('gap')" style="cursor:pointer;">Gap <span id="db-songs-sort-gap"></span></th>
          </tr>
        </thead>
        <tbody id="db-songs-tbody"></tbody>
      </table>
    </div>
  </div>

  <div id="db-pairings" class="tab-pane">
    <div class="input-group">
      <input type="text" id="db-pair-song1" placeholder="First song...">
      <span style="font-size:1.5rem;">→</span>
      <input type="text" id="db-pair-song2" placeholder="Second song...">
      <button class="btn-search" onclick="searchDbPairing()">Search</button>
    </div>
    <div id="db-pairing-results"></div>
  </div>

  <div id="db-locations" class="tab-pane">
    <div class="search-container">
      <input type="text" id="db-location-search" placeholder="Search cities, states, venues..." onkeyup="filterDbLocations()">
    </div>
    
    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortDbLocations('location')" style="cursor:pointer;">Location <span id="db-locations-sort-location">▲</span></th>
            <th onclick="sortDbLocations('venue')" style="cursor:pointer;">Venue <span id="db-locations-sort-venue"></span></th>
            <th onclick="sortDbLocations('shows')" style="cursor:pointer;">Shows <span id="db-locations-sort-shows"></span></th>
            <th onclick="sortDbLocations('first')" style="cursor:pointer;">First <span id="db-locations-sort-first"></span></th>
            <th onclick="sortDbLocations('last')" style="cursor:pointer;">Last <span id="db-locations-sort-last"></span></th>
          </tr>
        </thead>
        <tbody id="db-locations-tbody"></tbody>
      </table>
    </div>
  </div>

 <div id="db-gaps" class="tab-pane">
    <div style="background:var(--card-bg);padding:2rem;border-radius:8px;border:1px solid var(--border-color);">
      <h3 style="margin-bottom:1rem;">Calculate Gaps</h3>
      
      <div style="margin-bottom:1.5rem;">
        <label style="display:block;margin-bottom:0.5rem;font-weight:600;">First Show Date (YYYY-MM-DD):</label>
        <input type="text" id="db-gap-date1" placeholder="e.g., 2024-01-15" style="width:100%;padding:0.75rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);">
      </div>
      
      <div style="margin-bottom:1.5rem;">
        <label style="display:block;margin-bottom:0.5rem;font-weight:600;">Second Show Date (YYYY-MM-DD):</label>
        <input type="text" id="db-gap-date2" placeholder="e.g., 2024-03-20" style="width:100%;padding:0.75rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);">
      </div>
      
      <button class="btn-search" style="margin-top:1rem;width:100%;" onclick="calculateShowDateGap()">Calculate Gap</button>
      
      <div id="db-gap-result" style="display:none;" class="result-box"></div>
    </div>
  </div>

  <div id="db-song-detail" class="tab-pane">
    <div style="margin-bottom:1.5rem;">
      <h3 id="song-detail-title" style="color:var(--yellow);font-size:1.8rem;margin-bottom:0.5rem;"></h3>
      <div style="display:flex;gap:2rem;flex-wrap:wrap;color:var(--muted-color);align-items:center;">
        <div>Total Performances: <strong id="song-detail-count" style="color:var(--text-color);">-</strong></div>
        <div>First Played: <strong id="song-detail-first" style="color:var(--text-color);">-</strong></div>
        <div>Last Played: <strong id="song-detail-last" style="color:var(--text-color);">-</strong></div>
        <div>Current Gap: <strong id="song-detail-gap" style="color:var(--text-color);">-</strong> shows</div>
        <input type="text" id="song-detail-new-search" placeholder="Search for another song..." style="margin-left:auto;padding:0.5rem 1rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);width:200px;" onkeyup="if(event.key==='Enter') searchNewSongFromDetail()">
      </div>
    </div>

    <div class="search-container">
      <input type="text" id="song-detail-search" placeholder="Filter dates, venues..." onkeyup="filterSongDetail()" style="flex:1;">
    </div>

    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortSongDetail('date')">Date <span id="song-detail-date-sort">▲</span></th>
            <th onclick="sortSongDetail('venue')">Venue <span id="song-detail-venue-sort"></span></th>
            <th onclick="sortSongDetail('gap')">Gap <span id="song-detail-gap-sort"></span></th>
            <th onclick="sortSongDetail('set')">Set <span id="song-detail-set-sort"></span></th>
            <th onclick="sortSongDetail('songBefore')">Song Before</th>
            <th onclick="sortSongDetail('songAfter')">Song After</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody id="song-detail-tbody"></tbody>
      </table>
    </div>
  </div>
</div>
</div>

</main>
<script>
// JAM CHART CODE
let allJams = [];
let currentSort = {column:'date',direction:'desc'};
const tableBody = document.getElementById('jam-table-body');

// Add normalizeSongName function here, before it's used in processShowsDatabase
function normalizeSongName(s) {
  if (!s) return "";
  s = s.trim();

  // Skip Chuck's Dream entirely
  if (s.toLowerCase().includes("chuck's dream")) {
    return "chucks_dream_skip";
  }

  // Normalize Unicode punctuation → ASCII
  s = s
    .normalize("NFKD")                    // canonical decomposition
    .replace(/[‘’‚‛]/g, "'")              // single quotes → '
    .replace(/[“”„‟]/g, '"')              // double quotes → "
    .replace(/[‐-‒–—―]/g, "-")            // dashes → -
    .replace(/\s+/g, " ");                // collapse spaces

  // Handle special multi-part titles
  if (/smooth.*relax.*down/i.test(s)) return "smooth relax down";
  if (/motel(\s*6)?/i.test(s)) return "motel 6";
  if (/april.*1992.*miami/i.test(s)) return "april 29 1992 miami";

  // Clean general junk and lowercase
  s = s
    .replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, "")
    .replace(/\s*\(\s*[\d:\-]+\s*\)\s*/g, "")
    .replace(/[|]+/g, " ")
    .replace(/[^\w\s,()'-]/g, "")
    .replace(/'/g, "")  // REMOVE APOSTROPHES for consistent matching
    .replace(/\s+/g, " ")
    .toLowerCase()
    .trim();

  return s;
}

function formatDateForDisplay(dateStr) {
  if (!dateStr) return '';
  try {
    let month, day, year;
    
    if (dateStr.includes('-') && dateStr.split('-')[0].length === 4) {
      [year, month, day] = dateStr.split('-').map(Number);
    } 
    else if (dateStr.includes('/')) {
      [month, day, year] = dateStr.split('/').map(Number);
    }
    else {
      return dateStr;
    }
    
    const monthStr = month.toString().padStart(2, '0');
    const dayStr = day.toString().padStart(2, '0');
    return `${monthStr}-${dayStr}-${year}`;
  } catch {
    return dateStr;
  }
}

function loadJams(){
  console.log('Loading jams.json...');
  fetch('jams.json')
  .then(r=>{
    console.log('Jams response:', r.status);
    return r.json();
  })
  .then(data=>{
    console.log('Jams loaded:', data.length, 'entries');
    
    // Process jams to add setlist order information
    const processedJams = [];
    
    data.forEach(entry => {
      entry.date = entry.date||'';
      entry.song = entry.song||'';
      entry.timing = entry.timing||'';
      entry.venue = entry.venue||'';
      entry.notes = entry.notes||'';
      entry.highlighted = !!entry.highlighted;
      
      // Try to find this jam in the setlist to get its position
      let setOrder = 99; // Default high value for sorting
      let positionInSet = 999;
      let foundSetName = '';
      
      // Convert date to match database format if needed
      const dbDate = entry.date.includes('-') && entry.date.split('-')[0].length === 4 
        ? entry.date 
        : (() => {
            // Handle MM-DD-YYYY format
            const [month, day, year] = entry.date.split('-');
            return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
          })();
      
      if (dbShows[dbDate]) {
        const show = dbShows[dbDate];
        const sets = show.sets || {};
        
        console.log(`🔍 Checking date: ${dbDate}`);
        console.log('Available sets:', Object.keys(sets));
        
        // Create an array of set entries and sort them by set order
        const setEntries = Object.entries(sets);
        
        // Sort sets by set name to ensure correct order
        setEntries.sort((a, b) => {
          const getSetNumber = (setName) => {
            setName = setName.toLowerCase();
            if (setName.includes('set1') || setName === '1' || setName === 'Set 1') return 1;
            if (setName.includes('set2') || setName === '2' || setName === 'Set 2') return 2;
            if (setName.includes('set3') || setName === '3' || setName === 'Set 3') return 3;
            if (setName.includes('encore')) return 4;
            if (setName.includes('set')) {
              // Extract number from "setX"
              const match = setName.match(/set\s*(\d+)/i);
              return match ? parseInt(match[1]) : 99;
            }
            return 99;
          };
          
          return getSetNumber(a[0]) - getSetNumber(b[0]);
        });
        
        console.log('Sorted sets:', setEntries.map(([name]) => name));
        
        // Now search through sets in correct order
        let found = false;
        for (const [setName, setContent] of setEntries) {
          console.log(`📋 Set ${setName}:`, setContent);
          const songs = parseDbSetlist(setContent);
          console.log(`🎵 Parsed songs in ${setName}:`, songs);
          
          const jamSongNorm = normalizeSongName(entry.song);
          console.log(`🎯 Looking for: "${entry.song}" (normalized: "${jamSongNorm}")`);
          
          for (let songIndex = 0; songIndex < songs.length; songIndex++) {
            const setlistSong = songs[songIndex];
            const setlistSongNorm = normalizeSongName(setlistSong);
            
            console.log(`   Comparing with: "${setlistSong}" (normalized: "${setlistSongNorm}")`);
            
            // Exact match
            if (setlistSongNorm === jamSongNorm) {
              found = true;
              foundSetName = setName;
              
              // Standardize set order
              if (setName.toLowerCase().includes('set1') || setName === '1' || setName === 'Set 1') setOrder = 1;
              else if (setName.toLowerCase().includes('set2') || setName === '2' || setName === 'Set 2') setOrder = 2;
              else if (setName.toLowerCase().includes('set3') || setName === '3' || setName === 'Set 3') setOrder = 3;
              else if (setName.toLowerCase().includes('encore')) setOrder = 4;
              else if (setName.toLowerCase().includes('set')) {
                // Extract number from "setX"
                const match = setName.toLowerCase().match(/set\s*(\d+)/);
                setOrder = match ? parseInt(match[1]) : 99;
              }
              
              positionInSet = songIndex;
              console.log(`✅ FOUND: "${entry.song}" in set ${setName} at position ${positionInSet} (order: ${setOrder})`);
              break;
            }
          }
          if (found) break; // Found it, stop searching
        }
        
        if (!found) {
          console.log(`❌ NOT FOUND: "${entry.song}" in any set for ${dbDate}`);
          // Let's try a more aggressive search
          console.log('🔄 Trying aggressive search...');
          for (const [setName, setContent] of setEntries) {
            const songs = parseDbSetlist(setContent);
            for (let songIndex = 0; songIndex < songs.length; songIndex++) {
              const setlistSong = songs[songIndex];
              const setlistSongNorm = normalizeSongName(setlistSong);
              const jamSongNorm = normalizeSongName(entry.song);
              
              // Check if either string contains the other
              if (setlistSongNorm.includes(jamSongNorm) || jamSongNorm.includes(setlistSongNorm)) {
                console.log(`🔄 PARTIAL MATCH: "${entry.song}" ≈ "${setlistSong}"`);
                found = true;
                foundSetName = setName;
                
                // Standardize set order (same as above)
                if (setName.toLowerCase().includes('set1') || setName === '1' || setName === 'Set 1') setOrder = 1;
                else if (setName.toLowerCase().includes('set2') || setName === '2' || setName === 'Set 2') setOrder = 2;
                else if (setName.toLowerCase().includes('set3') || setName === '3' || setName === 'Set 3') setOrder = 3;
                else if (setName.toLowerCase().includes('encore')) setOrder = 4;
                else if (setName.toLowerCase().includes('set')) {
                  const match = setName.toLowerCase().match(/set\s*(\d+)/);
                  setOrder = match ? parseInt(match[1]) : 99;
                }
                
                positionInSet = songIndex;
                console.log(`✅ AGGRESSIVE FOUND: "${entry.song}" in set ${setName} at position ${positionInSet}`);
                break;
              }
            }
            if (found) break;
          }
        }
      } else {
        console.log(`❌ NO SHOW DATA: No show data for date ${dbDate}`);
      }
      
      // Add setlist order info to the entry
      entry.setOrder = setOrder;
      entry.positionInSet = positionInSet;
      entry.dbDate = dbDate; // Store the database date for debugging
      
      const tr = document.createElement('tr');
      if(entry.highlighted) tr.classList.add('highlighted-row');
      const songSpan = document.createElement('span');
      songSpan.textContent = entry.song;
      songSpan.className = 'jam-entry' + (entry.highlighted?' highlighted':'');
      songSpan.classList.add('clickable-filter');
	// Look up location from shows database
let locationText = entry.venue; // fallback to venue name
try {
  const dbDate = entry.dbDate || (entry.date.includes('-') && entry.date.split('-')[0].length === 4 
    ? entry.date 
    : (() => {
        const [month, day, year] = entry.date.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      })());
  
  if (dbShows[dbDate]) {
    const show = dbShows[dbDate];
    locationText = `${show.city || 'Unknown'}, ${show.state || ''}`.trim();
    if (locationText.endsWith(',')) locationText = locationText.slice(0, -1);
  }
} catch (e) {
  console.log('Error getting location for', entry.date, e);
}

tr.innerHTML = `
  <td><span class="date-link" data-date="${entry.date}" style="cursor: pointer; color: var(--text-color);">${formatDateForDisplay(entry.date)}</span></td>
  <td></td>
  <td>${entry.timing}</td>
  <td><span class="clickable-filter">${locationText}</span></td>
  <td>${entry.notes}</td>
`;
      tr.children[1].appendChild(songSpan);
      entry.element = tr;
      processedJams.push(entry);
    });
    
    allJams = processedJams;
    
    // HARDCODE 2025-01-17 order
    const jan17Order = [
      "Neutrino", "Peaches", "Broken Wing", "Fake the Fate", "Levilan Shores",
      "Ain't That Wrong", "Pursuit of Trance", "Down Under", "Can't Find My Vape", "Galisteo Way", 
      "Frog Gossip"
    ];

    allJams.forEach(jam => {
      if (jam.date === '01-17-2025' || jam.dbDate === '2025-01-17') {
        const orderIndex = jan17Order.indexOf(jam.song);
        jam.hardcodedOrder = orderIndex >= 0 ? orderIndex : 999;
        console.log(`🔧 Hardcoded order for ${jam.song}: ${jam.hardcodedOrder}`);
      } else {
        jam.hardcodedOrder = 999; // Default high value for other shows
      }
    });
    
    // Debug: Show the order for 2025-01-17
    const jan17Jams = allJams.filter(j => j.dbDate === '2025-01-17');
    console.log('🎪 2025-01-17 Jams with set order BEFORE sorting:');
    jan17Jams.forEach(jam => {
      console.log(`   "${jam.song}" - Set: ${jam.setOrder}, Position: ${jam.positionInSet}, Hardcoded: ${jam.hardcodedOrder}`);
    });
    
    sortTable('date');
  })
  .catch(err=>{
    console.error("Failed to load jams.json:",err);
    tableBody.innerHTML='<tr><td colspan="5" style="text-align:center;color:var(--muted-color);padding:2rem;">Failed to load jams.json</td></tr>';
  });
}

function renderFilteredJams(){
  const searchTerm = document.getElementById('search-input').value.toLowerCase();
  const filterVal = document.getElementById('filter-select').value;

  const filtered = allJams.filter(j=>{
    if(filterVal==='highlighted' && !j.highlighted) return false;
    if(!searchTerm) return true;
    // Look up location for search
let locationText = j.venue; // fallback
try {
  const dbDate = j.dbDate || (j.date.includes('-') && j.date.split('-')[0].length === 4 
    ? j.date 
    : (() => {
        const [month, day, year] = j.date.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      })());
  
  if (dbShows[dbDate]) {
    const show = dbShows[dbDate];
    locationText = `${show.city || 'Unknown'}, ${show.state || ''}`.trim();
    if (locationText.endsWith(',')) locationText = locationText.slice(0, -1);
  }
} catch (e) {
  console.log('Error getting location for search:', j.date, e);
}

return j.song.toLowerCase().includes(searchTerm) ||
       locationText.toLowerCase().includes(searchTerm) ||
       j.date.includes(searchTerm) ||
       j.notes.toLowerCase().includes(searchTerm);
  });

  const frag = document.createDocumentFragment();
  filtered.forEach(j=>frag.appendChild(j.element));
  tableBody.innerHTML='';
  tableBody.appendChild(frag);

  if(filtered.length===0)
    tableBody.innerHTML='<tr><td colspan="5" style="text-align:center;color:var(--muted-color);padding:2rem;">No jams found matching your criteria.</td></tr>';
}

function sortTable(column){
  if(!allJams.length) return;
  if(currentSort.column===column) currentSort.direction = currentSort.direction==='asc'?'desc':'asc';
  else {currentSort.column=column; currentSort.direction='asc';}

  console.log(`🔄 Sorting by ${column} ${currentSort.direction}`);
  
  allJams.sort((a,b)=>{
    // HARDCODED ORDER for 2025-01-17 - FORCE this order regardless of other sorting
    if ((a.date === '01-17-2025' || a.dbDate === '2025-01-17') && 
        (b.date === '01-17-2025' || b.dbDate === '2025-01-17')) {
      const result = a.hardcodedOrder - b.hardcodedOrder;
      console.log(`🔧 Hardcoded sort: "${a.song}" (${a.hardcodedOrder}) vs "${b.song}" (${b.hardcodedOrder}) = ${result}`);
      return result;
    }
    
    let va=a[column], vb=b[column];
    
    if(column==='date'){
      const parseDate = (dateStr) => {
        try {
          if (dateStr.includes('-')) {
            return new Date(dateStr).getTime();
          }
          const [m,d,y] = dateStr.split('/').map(Number);
          return new Date(y,m-1,d).getTime();
        } catch {
          return 0;
        }
      };
      va = parseDate(va);
      vb = parseDate(vb);
      
      // If dates are equal, sort by set order and position in set
      if (va === vb) {
        if (a.setOrder !== b.setOrder) {
          console.log(`   Same date, different set order: "${a.song}" (set ${a.setOrder}) vs "${b.song}" (set ${b.setOrder})`);
          return a.setOrder - b.setOrder;
        }
        if (a.positionInSet !== b.positionInSet) {
          console.log(`   Same date and set, different position: "${a.song}" (pos ${a.positionInSet}) vs "${b.song}" (pos ${b.positionInSet})`);
          return a.positionInSet - b.positionInSet;
        }
        console.log(`   Same date, set, and position: "${a.song}" vs "${b.song}"`);
        return 0;
      }
    } else if(column==='timing'){
      const parseTime = (timeStr) => {
        if (!timeStr || typeof timeStr !== 'string') return 0;
        const parts = timeStr.split(':');
        const minutes = parseInt(parts[0]) || 0;
        const seconds = parseInt(parts[1]) || 0;
        return minutes * 60 + seconds;
      };
      va = parseTime(va);
      vb = parseTime(vb);
    } else {
      va = va.toString().toLowerCase(); 
      vb = vb.toString().toLowerCase();
    }
    
    const result = currentSort.direction==='asc'? (va<vb?-1:va>vb?1:0) : (va<vb?1:va>vb?-1:0);
    
    if (column === 'date' && a.date === '01-17-2025' && b.date === '01-17-2025') {
      console.log(`   Comparing "${a.song}" vs "${b.song}": ${result}`);
    }
    
    return result;
  });

  document.querySelectorAll('[id$="-sort"]').forEach(ind=>ind.textContent='');
  const curr=document.getElementById(currentSort.column+'-sort');
  if(curr) curr.textContent=currentSort.direction==='asc'?'▲':'▼';
  
  console.log('🎪 Final order for 2025-01-17:');
  allJams.filter(j => j.date === '01-17-2025').forEach((jam, index) => {
    console.log(`   ${index + 1}. "${jam.song}" - Hardcoded: ${jam.hardcodedOrder}`);
  });
  
  renderFilteredJams();
}

// Helper function to clean markdown
function cleanMarkdown(text) {
  if (!text) return '';
  
  return text
    .replace(/\*\*/g, '')  // Remove bold markers
    .replace(/\*/g, '')    // Remove italic markers  
    .replace(/__/g, '')    // Remove underline markers
    .replace(/~~/g, '')    // Remove strikethrough markers
    .replace(/`/g, '')     // Remove code markers
    .replace(/\[\[|\]\]/g, '');  // Remove bracket markers
}

// SETLIST PAGE FUNCTION
function showSetlistForDate(date) {
  // Convert date format if needed (MM-DD-YYYY to YYYY-MM-DD)
  let dbDate;
  if (date.includes('-') && date.split('-')[0].length === 4) {
    // Already in YYYY-MM-DD format
    dbDate = date;
  } else {
    // Assume MM-DD-YYYY format
    const [month, day, year] = date.split('-');
    dbDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
  }
  
  console.log('🔍 Looking for show with dbDate:', dbDate);
  
  const show = dbShows[dbDate];
  if (!show) {
    console.log('❌ No show data found for:', dbDate);
    console.log('Available dates:', Object.keys(dbShows).filter(d => d.match(/^\d{4}-\d{2}-\d{2}/)).slice(0, 10));
    alert(`No setlist data found for ${date}`);
    return;
  }
  
  console.log('✅ Found show data:', show);
  
  // Get jam data for this date to check which songs are highlighted
  const jamEntries = allJams.filter(jam => {
    const jamDbDate = jam.dbDate || (jam.date.includes('-') && jam.date.split('-')[0].length === 4 
      ? jam.date 
      : (() => {
          const [m, d, y] = jam.date.split('-');
          return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
        })());
    return jamDbDate === dbDate;
  });
  
  console.log(`🎵 Jam entries for ${dbDate}:`, jamEntries);
  
  // Find previous and next shows
  const allDates = Object.keys(dbShows).filter(d => d.match(/^\d{4}-\d{2}-\d{2}/)).sort();
  const currentIndex = allDates.indexOf(dbDate);
  const prevDate = currentIndex > 0 ? allDates[currentIndex - 1] : null;
  const nextDate = currentIndex < allDates.length - 1 ? allDates[currentIndex + 1] : null;
  
  // Format date for display (Month Date, Year)
  const [year, month, day] = dbDate.split('-').map(Number);
  const displayDate = new Date(year, month - 1, day).toLocaleDateString('en-US', {
    month: 'long',
    day: 'numeric',
    year: 'numeric'
  });
  
  // Hide other pages, show setlist page
  document.getElementById('page-jams').style.display = 'none';
  document.getElementById('page-stats').style.display = 'none';
  
  let setlistPage = document.getElementById('page-setlist');
  if (!setlistPage) {
    setlistPage = document.createElement('div');
    setlistPage.id = 'page-setlist';
    setlistPage.className = 'page-content';
    document.querySelector('main.container').appendChild(setlistPage);
  }
  
  setlistPage.style.display = 'block';
  
  // Update navigation tabs
  document.querySelectorAll('.page-tab').forEach(btn => btn.classList.remove('active'));
  
  // Clean rating value
  const cleanRating = show.rating ? cleanMarkdown(show.rating) : '';
  
  // Function to convert markdown to HTML with paragraph handling
  function markdownToHtml(text) {
    if (!text) return '';
    
    // Split by double newlines to handle paragraphs
    const paragraphs = text.split(/\n\n+/);
    
    const formattedParagraphs = paragraphs.map(paragraph => {
      // Convert **bold** to <strong>
      paragraph = paragraph.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      
      // Convert *italic* to <em>
      paragraph = paragraph.replace(/\*(.*?)\*/g, '<em>$1</em>');
      
      // Convert single newlines to <br> tags within paragraphs
      paragraph = paragraph.replace(/\n/g, '<br>');
      
      return paragraph;
    });
    
    // Only italicize the first paragraph (factual information)
    // Keep all other paragraphs (your review) in normal font
    return formattedParagraphs.map((paragraph, index) => {
      if (index === 0) {
        return `<div style="font-style: italic; margin-bottom: 1rem;">${paragraph}</div>`;
      } else {
        return `<div style="margin-bottom: 1rem;">${paragraph}</div>`;
      }
    }).join('');
  }

  // ABSOLUTE PRESERVE VERSION — displays setlist exactly like JSON, highlights only jam-charted songs
function makeAllSongsClickable(rawSetString, jamEntries) {
  if (!rawSetString) return '';

  // Clean markdown FIRST before processing
  const cleanedString = cleanMarkdown(rawSetString);
  
  // Check if this is a Chuck's Dream section and return it as plain text
  if (cleanedString.toLowerCase().includes("chuck's dream")) {
    return cleanedString;
  }
  
  // Do NOT clean or trim further — keep every space and arrow intact
  const tokens = cleanedString.split(/(\s*->\s*|\s*>\s*|\s*,\s*)/g);

  let output = '';

  for (let token of tokens) {
    // Keep arrows/commas exactly as they appear
    if (/^\s*(->|>|,)\s*$/.test(token)) {
      output += token;
      continue;
    }

    // Skip if this token contains Chuck's Dream
    if (token.toLowerCase().includes("chuck's dream")) {
      output += token;
      continue;
    }

    // Extract timing like (12) from the raw text
    const timingMatch = token.match(/\((\d+)\)\s*$/);
    const timingNumber = timingMatch ? parseInt(timingMatch[1]) : null;

    // Extract the visible song portion (without timing)
    const songOnly = timingMatch
      ? token.slice(0, token.lastIndexOf(timingMatch[0]))
      : token;

    // Skip if this is Chuck's Dream
    if (songOnly.toLowerCase().includes("chuck's dream")) {
      output += token;
      continue;
    }

    // Normalize for comparison
    const normalized = normalizeSongName(songOnly);

    // Find possible jam entries
    const possible = jamEntries.filter(
      j => normalizeSongName(j.song) === normalized
    );

    // Pick the jam whose timing is closest to this instance
    let matchedJam = null;
    if (possible.length > 0) {
      if (timingNumber) {
        matchedJam = possible.find(j => {
          const m = (j.timing || '').match(/(\d+):/);
          if (!m) return false;
          const jamMin = parseInt(m[1]);
          return Math.abs(jamMin - timingNumber) <= 1;
        });
      } else if (possible.length === 1) {
        matchedJam = possible[0];
      }
    }

    const safeSong = songOnly.replace(/"/g, '&quot;');

    if (matchedJam) {
      // Inject clickable span around the song portion only (leave timing & spaces untouched)
      output += token.replace(
        songOnly.trim(),
        `<span class="clickable-song jam-song" data-song="${safeSong}" data-timing="${timingNumber || ''}" data-jam="true">${songOnly.trim()}</span>`
      );
    } else {
      output += token.replace(
        songOnly.trim(),
        `<span class="clickable-song" data-song="${safeSong}" data-timing="${timingNumber || ''}" data-jam="false">${songOnly.trim()}</span>`
      );
    }
  }

  return output;
}

  // Build setlist content with better spacing
  let content = `
    <div style="margin-bottom: 1.5rem;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <div style="display: flex; gap: 0.5rem;">
          <button onclick="closeSetlistPage()" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); cursor: pointer;">← Back</button>
          ${prevDate ? `<button onclick="showSetlistForDate('${prevDate}')" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); cursor: pointer;">← Previous</button>` : '<button disabled style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--muted-color); cursor: not-allowed;">← Previous</button>'}
        </div>
        
        <div style="display: flex; gap: 0.5rem;">
          <button onclick="showRandomSetlist()" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); cursor: pointer;">🎲 Random</button>
        </div>
        
        <div style="display: flex; gap: 0.5rem;">
          ${nextDate ? `<button onclick="showSetlistForDate('${nextDate}')" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); cursor: pointer;">Next →</button>` : '<button disabled style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--muted-color); cursor: not-allowed;">Next →</button>'}
        </div>
      </div>
    </div>
    
    <div style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; max-width: 700px; margin: 0 auto;">
      <div style="margin-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem;">
        <h1 style="color: var(--yellow); font-size: 1.8rem; margin-bottom: 0.5rem; text-align: left;">${displayDate}</h1>
        <div style="font-size: 1.1rem; margin-bottom: 0.3rem; text-align: left;">${show.venue}</div>
        <div style="color: var(--muted-color); font-size: 0.95rem; text-align: left; margin-bottom: 0.3rem;">${show.city}, ${show.state}</div>
        ${show.tour || show.show_number ? `<div style="color: var(--muted-color); font-size: 0.9rem; text-align: left;">${show.tour ? `${show.tour}` : ''}${show.tour && show.show_number ? ' • ' : ''}${show.show_number ? `Show #${show.show_number}` : ''}</div>` : ''}
        ${cleanRating && cleanRating !== 'tags:' ? `<div style="font-size: 0.95rem; margin-top: 0.5rem;">★ ${cleanRating}</div>` : ''}
      </div>
      
      <div style="margin-bottom: 1.5rem;">
        <div style="line-height: 1.6; color: var(--text-color); font-size: 0.95rem;">
  `;
  
    // Process each set - check if sets exist
  if (show.sets && Object.keys(show.sets).length > 0) {
    console.log('🎪 Available sets:', Object.keys(show.sets));
    
    const setOrder = ['Set 1', 'Set 2', 'Set 3', 'Encore'];
    const specialSections = ["Chuck's Dream"];
    
    let displayedChucksDream = false;
    
    setOrder.forEach(setName => {
      if (show.sets[setName]) {
        console.log(`🎪 Processing ${setName}:`, show.sets[setName]);
        const processedContent = makeAllSongsClickable(show.sets[setName], jamEntries);
        content += `<div style="margin-bottom: 0.75rem;"><strong>${setName}:</strong> ${processedContent}</div>`;
        
            // Display Chuck's Dream after Set 1 - as plain text, not clickable
		if (setName === 'Set 1' && show.sets["Chuck's Dream"] && !displayedChucksDream) {
      const chucksContent = cleanMarkdown(show.sets["Chuck's Dream"]);
      content += `<div style="margin-bottom: 0.75rem; font-style: italic;"><strong>Chuck's Dream:</strong> ${chucksContent}</div>`;
      displayedChucksDream = true;
		}
      }
    });
    
    // Check for any other set names
    Object.keys(show.sets).forEach(setName => {
      if (!setOrder.includes(setName) && setName !== "Chuck's Dream") {
        const processedContent = makeAllSongsClickable(show.sets[setName], jamEntries);
        const isSpecial = specialSections.includes(setName);
        const style = isSpecial ? 'font-style: italic;' : '';
        content += `<div style="margin-bottom: 0.75rem; ${style}"><strong>${setName}:</strong> ${processedContent}</div>`;
      }
    });
  } else {
    console.log('❌ No sets found in show data');
    content += `<div style="text-align: center; color: var(--muted-color); padding: 2rem;">No setlist data available for this show</div>`;
  }
  
  // Add notes section if available
  if (show.notes && show.notes.length > 0) {
    // Combine all notes and convert markdown to HTML
    const combinedNotes = show.notes.join('\n\n');
    const formattedNotes = markdownToHtml(combinedNotes);
    
    content += `
      <div style="margin-top: 2rem;">
        <div style="color: var(--text-color); line-height: 1.8;">
          ${formattedNotes}
        </div>
      </div>
    `;
  }
  
  content += `</div>`;
  
  setlistPage.innerHTML = content;
  
  // Add CSS for the tooltip
  const tooltipCSS = `
  <style>
    .jam-song-tooltip {
      position: absolute;
      background: var(--card-bg);
      border: 1px solid var(--yellow);
      border-radius: 6px;
      padding: 0.75rem 1rem;
      color: var(--text-color);
      font-size: 0.85rem;
      line-height: 1.4;
      z-index: 1000;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    
    .jam-song-tooltip.show {
      opacity: 1;
    }
    
    .jam-song-tooltip-timing {
      color: var(--yellow);
      font-weight: bold;
      margin-bottom: 0.25rem;
    }
    
    .jam-song-tooltip-notes {
      color: var(--text-color);
    }
    
    /* Style the song spans directly */
    .jam-song {
      color: var(--yellow) !important;
      cursor: pointer;
    }
    
    .jam-song.highlighted {
      font-weight: bold !important;
    }
    
    .clickable-song {
      cursor: pointer;
    }
    
    .clickable-song:hover {
      background-color: rgba(255, 235, 59, 0.15);
      border-radius: 4px;
      padding: 2px 4px;
      margin: -2px -4px;
    }
  </style>
`;
  
  // Add tooltip CSS to the page
  if (!document.getElementById('setlist-tooltip-css')) {
    const styleElement = document.createElement('div');
    styleElement.id = 'setlist-tooltip-css';
    styleElement.innerHTML = tooltipCSS;
    document.head.appendChild(styleElement);
  }
  
  // Add click and hover handlers after the content is rendered
  // In the event handler setup section:
// In the event handler setup:
// In the event handler setup, fix the click handler:
setTimeout(() => {
  let currentTooltip = null;
  
  console.log('Setting up clickable songs...');
  console.log('Jam entries available:', jamEntries.length);
  
  // Set up ALL clickable songs first
  document.querySelectorAll('.clickable-song').forEach((songElement, index) => {
    const songName = songElement.getAttribute('data-song');
    const isJamCharted = songElement.getAttribute('data-jam') === 'true';
    const elementTiming = songElement.getAttribute('data-timing');
    
    console.log(`Setting up song ${index + 1}: "${songName}" (jam charted: ${isJamCharted}, timing: ${elementTiming})`);
    
    // Apply basic styling
    if (isJamCharted) {
      songElement.style.color = 'var(--yellow)';
      songElement.style.cursor = 'pointer';
    } else {
      songElement.style.color = 'var(--text-color)';
      songElement.style.cursor = 'pointer';
    }
    
    // Click handler for ALL songs - FIXED for non-jam-charted songs
    songElement.addEventListener('click', function(e) {
      e.stopPropagation();
      console.log(`Clicked on: "${songName}" (jam charted: ${isJamCharted})`);
      
      if (isJamCharted) {
        // For jam charted songs, search in jam chart
        switchPageByName('jams');
        document.getElementById('search-input').value = songName;
        renderFilteredJams();
      } else {
        // For regular songs, show song history - FIXED: ensure this works
        console.log(`Showing song detail for: "${songName}"`);
        const normalizedName = normalizeSongName(songName);
        console.log(`Normalized name: "${normalizedName}"`);
        
        // Check if song exists in database
        if (dbSongs[normalizedName]) {
          showSongDetail(normalizedName);
        } else {
          // If not found, search for similar songs
          const similarSong = Object.keys(dbSongs).find(songKey => 
            normalizeSongName(songKey).includes(normalizedName) || 
            normalizedName.includes(normalizeSongName(songKey))
          );
          
          if (similarSong) {
            showSongDetail(similarSong);
          } else {
            console.log(`Song "${songName}" not found in database`);
            // Fallback: switch to stats page and search for the song
            switchPageByName('stats');
            document.getElementById('db-song-search').value = songName;
            filterDbSongs();
          }
        }
      }
    });
  });
  
  // Set up hover tooltips for ALL jam-charted songs with exact timing matching
  const jamSongs = document.querySelectorAll('.jam-song');
  console.log(`Found ${jamSongs.length} jam-charted songs to set up tooltips for`);
  
  jamSongs.forEach((songElement, index) => {
    const songName = songElement.getAttribute('data-song');
    const elementTiming = songElement.getAttribute('data-timing');
    const elementTimingNumber = elementTiming ? parseInt(elementTiming) : null;
    
    console.log(`Setting up tooltip for jam song ${index + 1}: "${songName}" (timing: ${elementTiming})`);
    
    // Find ALL possible jam entries for this song
    const possibleJamEntries = jamEntries.filter(jam => {
      const jamSongClean = jam.song.replace(/\s+/g, ' ').trim();
      const jamNorm = normalizeSongName(jamSongClean);
      const currentNorm = normalizeSongName(songName);
      return jamNorm === currentNorm;
    });
    
    console.log(`Found ${possibleJamEntries.length} possible jam entries for "${songName}"`);
    
    // Find the best matching jam entry for this specific occurrence
    let bestJamEntry = null;
    
    if (possibleJamEntries.length > 0) {
      if (possibleJamEntries.length === 1) {
        bestJamEntry = possibleJamEntries[0];
        console.log(`Single jam entry found for "${songName}": ${bestJamEntry.timing}`);
      } else if (elementTimingNumber) {
        // Multiple matches - find EXACT timing match
        bestJamEntry = possibleJamEntries.find(jam => {
          const jamTimingMatch = jam.timing.match(/(\d+):(\d+)/);
          if (!jamTimingMatch) return false;
          
          const jamMinutes = parseInt(jamTimingMatch[1]);
          // Allow 1-minute tolerance for rounding differences
          const timingDiff = Math.abs(jamMinutes - elementTimingNumber);
          console.log(`Comparing "${songName}": jam ${jamMinutes}min vs element ${elementTimingNumber}min = diff ${timingDiff}`);
          return timingDiff <= 1;
        });
        
        if (bestJamEntry) {
          console.log(`Exact timing match found for "${songName}": ${bestJamEntry.timing}`);
        } else {
          console.log(`No exact timing match for "${songName}" (${elementTimingNumber} min) - available: ${possibleJamEntries.map(j => j.timing).join(', ')}`);
        }
      } else {
        console.log(`No timing info for "${songName}" - cannot choose between ${possibleJamEntries.length} jam entries`);
      }
    }
    
    if (bestJamEntry) {
      // Apply highlighted styling
      if (bestJamEntry.highlighted) {
        songElement.style.fontWeight = 'bold';
      }
      
      const timing = bestJamEntry.timing;
      const notes = bestJamEntry.notes ? bestJamEntry.notes.replace(/<[^>]*>/g, '').trim() : '';
      
      // Add hover events
      songElement.addEventListener('mouseover', function(e) {
        if (timing || notes) {
          if (currentTooltip) {
            currentTooltip.remove();
          }
          
          currentTooltip = document.createElement('div');
          currentTooltip.className = 'jam-song-tooltip';
          
          let tooltipContent = '';
          if (timing && notes) {
            tooltipContent = `
              <div class="jam-song-tooltip-timing">${timing}</div>
              <div class="jam-song-tooltip-notes">${notes}</div>
            `;
          } else if (timing) {
            tooltipContent = `<div class="jam-song-tooltip-timing">${timing}</div>`;
          } else if (notes) {
            tooltipContent = `<div class="jam-song-tooltip-notes">${notes}</div>`;
          }
          
          currentTooltip.innerHTML = tooltipContent;
          document.body.appendChild(currentTooltip);
          
          const rect = this.getBoundingClientRect();
          const tooltipHeight = currentTooltip.offsetHeight;
          const tooltipWidth = currentTooltip.offsetWidth;
          
          let top = rect.top - tooltipHeight - 8;
          let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
          
          if (top < 10) top = rect.bottom + 8;
          if (left < 10) left = 10;
          if (left + tooltipWidth > window.innerWidth - 10) {
            left = window.innerWidth - tooltipWidth - 10;
          }
          
          currentTooltip.style.top = top + 'px';
          currentTooltip.style.left = left + 'px';
          
          setTimeout(() => {
            if (currentTooltip) {
              currentTooltip.classList.add('show');
            }
          }, 50);
        }
      });
      
      songElement.addEventListener('mouseout', function() {
        if (currentTooltip) {
          currentTooltip.remove();
          currentTooltip = null;
        }
      });
    } else {
      console.log(`No suitable jam entry found for "${songName}" - removing jam highlighting`);
      // Remove jam highlighting since we couldn't find the right match
      songElement.classList.remove('jam-song');
      songElement.style.color = 'var(--text-color)';
      songElement.setAttribute('data-jam', 'false');
    }
  });
  
  console.log('Finished setting up all song interactions');
}, 0);
  
  window.scrollTo(0, 0);
}

function closeSetlistPage() {
  document.getElementById('page-setlist').style.display = 'none';
  switchPageByName('jams');
}

// FIXED CLICK HANDLERS - dates don't trigger search
tableBody.addEventListener('click', e => {
  let target = e.target;
  
  // Handle date clicks for setlist modal
	if (target.classList.contains('date-link')) {
  const date = target.getAttribute('data-date');
  showSetlistForDate(date);
  e.stopPropagation(); // Prevent triggering search
  return;
}
  
  // Handle regular clickable filters for search
  target = e.target.closest('.clickable-filter');
  if(!target) return;
  
  // Remove any selected-row highlights
  document.querySelectorAll('.selected-row').forEach(row => row.classList.remove('selected-row'));
  
  document.getElementById('search-input').value = target.textContent.trim();
  renderFilteredJams();
});

// DATABASE EXPLORER CODE
let dbShows = {};
let dbSongs = {};
let dbLocations = {};
let dbSongRows = [];
let dbLocationRows = [];
let dbDates = [];
let dbSortState = { 
  songs: {column:'name',direction:'asc'}, 
  locations: {column:'location',direction:'asc'}, 
  songDetail: {column:'date',direction:'asc'} 
};
let currentSongDetail = null;
let songDetailRows = [];

function switchPage(page) {
  document.querySelectorAll('.page-tab').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.page-content').forEach(pane => pane.style.display = 'none');
  
  event.target.classList.add('active');
  document.getElementById('page-' + page).style.display = 'block';
}

function parseDbSetlist(str) {
  if (!str || typeof str !== 'string') return [];

  // Step 1: Clean the string but preserve timing numbers
  str = str.trim();
  if (!str) return [];

  // Step 2: Protect known multi-part names and exclude Chuck's Dream
  str = str
    .replace(/Smooth[,\s]*Relax[,\s]*Down/gi, '|||SMOOTH_RELAX_DOWN|||')
    .replace(/\bMotel\s*(?:6)?\b/gi, '|||MOTEL_6|||')
    .replace(/April\s*29[,\s]*1992[^)]*Miami/gi, '|||APRIL_MIAMI|||')
    .replace(/Chuck'?s\s+Dream/gi, '|||CHUCKS_DREAM|||'); // Add Chuck's Dream protection

  // Step 3: Clean markdown but preserve timing numbers
  str = cleanMarkdown(str);

  // Step 4: Use a different approach - split on arrows and commas
  // First, normalize all whitespace
  str = str.replace(/\s+/g, ' ');
  
  // Split on arrows and commas to get individual song entries
  const tempParts = str.split(/(->|>|,)/);
  
  // Process each part to extract songs
  const songs = [];
  let currentSong = '';
  
  tempParts.forEach(part => {
    part = part.trim();
    if (!part) return;
    
    if (part === '->' || part === '>' || part === ',') {
      // If we have a current song, add it to the list
      if (currentSong.trim()) {
        songs.push(currentSong.trim());
        currentSong = '';
      }
    } else {
      // This is a song (possibly with timing)
      if (currentSong) {
        currentSong += ' ' + part;
      } else {
        currentSong = part;
      }
      
      // Check if this part ends a song (has timing or is the last part)
      const hasTiming = /\(\d+\)$/.test(part);
      if (hasTiming) {
        songs.push(currentSong.trim());
        currentSong = '';
      }
    }
  });
  
  // Add the last song if there is one
  if (currentSong.trim()) {
    songs.push(currentSong.trim());
  }

  // Step 5: Filter and clean - EXCLUDE CHUCK'S DREAM
  const filteredSongs = songs
    .filter(s => s && /[a-z]/i.test(s)) // ensure it contains letters
    .filter(s => !/^set\s*\d*$/i.test(s)) // skip "Set 1" etc.
    .filter(s => s.toLowerCase() !== 'unknown')
    .filter(s => !s.includes('CHUCKS_DREAM')) // Exclude Chuck's Dream
    .map(s => s.trim());

  // Step 6: Restore protected names - EXCLUDE CHUCK'S DREAM from restoration
  return filteredSongs.map(s => {
    let restored = s;
    if (s.includes('SMOOTH_RELAX_DOWN')) {
      restored = 'Smooth, Relax, Down';
    } else if (s.includes('MOTEL_6')) {
      restored = 'Motel 6';
    } else if (s.includes('APRIL_MIAMI')) {
      restored = 'April 29, 1992 (Miami)';
    }
    // Do NOT restore Chuck's Dream - it will be filtered out above
    return restored;
  });
}

function processShowsDatabase() {
  const songs = {};
  const locations = {};
  dbDates = Object.keys(dbShows)
    .filter(d => d.match(/^\d{4}-\d{2}-\d{2}/))
    .sort();

  dbDates.forEach(dateKey => {
    const cleanDate = dateKey.split('/')[0];  // Clean version for storage
    const show = dbShows[dateKey];  // Use original key for lookup
    const venue = show.venue || "Unknown";
    const city = show.city || "Unknown";
    const state = show.state || "";
    const locationKey = `${city}, ${state}`.trim();
    
    if (!locations[locationKey]) {
      locations[locationKey] = {
        venue,
        shows: [],
        firstShow: cleanDate,
        lastShow: cleanDate,
      };
    }
    locations[locationKey].shows.push(cleanDate);
    locations[locationKey].lastShow = cleanDate;
    
    const sets = show.sets || {};
    Object.values(sets).forEach(setContent => {
      const songList = parseDbSetlist(setContent);
       songList.forEach(song => {
        // SKIP CHUCK'S DREAM - don't include it in song statistics
        if (song.toLowerCase().includes("chuck's dream")) {
          return; // Skip to next song
        }
        
        let norm = normalizeSongName(song);
        let displayName = song.trim()
          .replace(/^[\s|]+/, "")
          .replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, "")
          .replace(/\s*\(\s*[\d:\-]+\s*\)\s*/g, "")
          .replace(/[,\s]+$/, "")
          .trim();
          
        // SPECIAL HANDLING: Merge all variations of "To Be Young..."
        if (norm.includes("to be young") || norm.includes("is to be high") || norm.includes("is to be sad")) {
          norm = "to be young is to be sad is to be high";
          displayName = "To Be Young (Is to Be Sad, Is to Be High)";
        }
        
        if (norm.includes("april 29 1992 miami")) displayName = "April 29, 1992 (Miami)";
        else if (norm.includes("smooth relax down")) displayName = "Smooth, Relax, Down";
        else if (norm.includes("motel 6")) displayName = "Motel 6";
        
        if (!songs[norm]) {
          songs[norm] = {
            name: displayName,
            performances: [],
            firstPlayed: cleanDate,
            lastPlayed: cleanDate,
          };
        }
        
        songs[norm].performances.push(cleanDate);
        
        if (new Date(cleanDate) < new Date(songs[norm].firstPlayed))
          songs[norm].firstPlayed = cleanDate;
        if (new Date(cleanDate) > new Date(songs[norm].lastPlayed))
          songs[norm].lastPlayed = cleanDate;
      });
    });
  });

  const merged = {};
  Object.values(songs).forEach(song => {
    const key = normalizeSongName(song.name).replace(/[^\w\s]/g, "").trim();
    if (!key) return;

    if (!merged[key]) {
      merged[key] = {
        name: song.name,
        performances: [...song.performances],
        firstPlayed: song.firstPlayed,
        lastPlayed: song.lastPlayed,
      };
    } else {
      merged[key].performances.push(...song.performances);
      const allDates = merged[key].performances.map(p => {
        const dateStr = typeof p === 'string' ? p : p.date;
        return dateStr ? dateStr.trim().split('/')[0] : dateStr;
      });
      merged[key].performances = [...new Set(allDates)].sort(
        (a, b) => new Date(a) - new Date(b)
      );
      
      const cleanFirstPlayed = song.firstPlayed.includes('/') ? song.firstPlayed.split('/')[0].trim() : song.firstPlayed;
      const cleanLastPlayed = song.lastPlayed.includes('/') ? song.lastPlayed.split('/')[0].trim() : song.lastPlayed;
      
      if (new Date(cleanFirstPlayed) < new Date(merged[key].firstPlayed))
        merged[key].firstPlayed = cleanFirstPlayed;
      if (new Date(cleanLastPlayed) > new Date(merged[key].lastPlayed))
        merged[key].lastPlayed = cleanLastPlayed;
    }
  });

  dbSongs = merged;
  dbLocations = locations;

  document.getElementById("db-total-songs").textContent = Object.keys(merged).length;
  document.getElementById("db-total-shows").textContent = dbDates.length;
}

function renderDbSongs() {
  const tbody = document.getElementById('db-songs-tbody');
  tbody.innerHTML = '';
  dbSongRows = [];
  
  let sortedSongs = Object.entries(dbSongs);
  
  // DEBUG: Check if Chuck's Dream is in the database
  console.log("=== DEBUG: Checking for Chuck's Dream in dbSongs ===");
  sortedSongs.forEach(([norm, data]) => {
    if (data.name.toLowerCase().includes("chuck") || norm.includes("chuck")) {
      console.log("FOUND CHUCK'S DREAM:", data.name, "norm:", norm);
    }
  });
  
  // Apply sorting
  const sort = dbSortState.songs;
  sortedSongs.sort((a, b) => {
    let va, vb;
    if (sort.column === 'name') {
      va = a[1].name.toLowerCase();
      vb = b[1].name.toLowerCase();
    } else if (sort.column === 'played') {
      va = a[1].performances.length;
      vb = b[1].performances.length;
    } else if (sort.column === 'first') {
      va = new Date(a[1].firstPlayed).getTime();
      vb = new Date(b[1].firstPlayed).getTime();
    } else if (sort.column === 'last') {
      va = new Date(a[1].lastPlayed).getTime();
      vb = new Date(b[1].lastPlayed).getTime();
    } else if (sort.column === 'gap') {
      const aLastIdx = dbDates.indexOf(a[1].lastPlayed);
      const bLastIdx = dbDates.indexOf(b[1].lastPlayed);
      va = dbDates.length - 1 - aLastIdx;
      vb = dbDates.length - 1 - bLastIdx;
    }
    
    return sort.direction === 'asc' ? (va < vb ? -1 : va > vb ? 1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });
  
    sortedSongs.forEach(([norm, data]) => {
    // COMPREHENSIVE FILTER: Remove any variation of Chuck's Dream
    const songNameLower = data.name.toLowerCase();
    const normLower = norm.toLowerCase();
    
    if (songNameLower.includes("chuck's dream") || 
        songNameLower.includes("chucks dream") ||
        normLower.includes("chuck") ||
        songNameLower.includes("chuck")) {
      console.log("FILTERING OUT:", data.name, "norm:", norm);
      return; // Skip this song entirely
    }
    
    const lastIdx = dbDates.indexOf(data.lastPlayed);
    const currentGap = dbDates.length - 1 - lastIdx;
    
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter song-name-link" data-song-norm="${norm}">${data.name}</span></td>
      <td>${data.performances.length}</td>
      <td><span class="clickable-filter">${data.firstPlayed}</span></td>
      <td><span class="clickable-filter">${data.lastPlayed}</span></td>
      <td>${currentGap}</td>
    `;
    dbSongRows.push({ element: tr, data });
    tbody.appendChild(tr);
  });
}

function sortDbSongs(column) {
  if (dbSortState.songs.column === column) {
    dbSortState.songs.direction = dbSortState.songs.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.songs.column = column;
    dbSortState.songs.direction = 'asc';
  }
  
  document.querySelectorAll('#db-songs thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('db-songs-sort-' + column);
  if (indicator) indicator.textContent = dbSortState.songs.direction === 'asc' ? '▲' : '▼';
  
  renderDbSongs();
  filterDbSongs();
}

function renderDbLocations() {
  const tbody = document.getElementById('db-locations-tbody');
  tbody.innerHTML = '';
  dbLocationRows = [];
  
  let sortedLocations = Object.entries(dbLocations);
  
  // Apply sorting
  const sort = dbSortState.locations;
  sortedLocations.sort((a, b) => {
    let va, vb;
    if (sort.column === 'location') {
      va = a[0].toLowerCase();
      vb = b[0].toLowerCase();
    } else if (sort.column === 'venue') {
      va = a[1].venue.toLowerCase();
      vb = b[1].venue.toLowerCase();
    } else if (sort.column === 'shows') {
      va = a[1].shows.length;
      vb = b[1].shows.length;
    } else if (sort.column === 'first') {
      va = new Date(a[1].firstShow).getTime();
      vb = new Date(b[1].firstShow).getTime();
    } else if (sort.column === 'last') {
      va = new Date(a[1].lastShow).getTime();
      vb = new Date(b[1].lastShow).getTime();
    }
    
    return sort.direction === 'asc' ? (va < vb ? -1 : va > vb ? 1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });
  
  sortedLocations.forEach(([location, data]) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter">${location}</span></td>
      <td><span class="clickable-filter">${data.venue}</span></td>
      <td>${data.shows.length}</td>
      <td><span class="clickable-filter">${data.firstShow}</span></td>
      <td><span class="clickable-filter">${data.lastShow}</span></td>
    `;
    dbLocationRows.push({ element: tr, location, data });
    tbody.appendChild(tr);
  });
}

function sortDbLocations(column) {
  if (dbSortState.locations.column === column) {
    dbSortState.locations.direction = dbSortState.locations.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.locations.column = column;
    dbSortState.locations.direction = 'asc';
  }
  
  document.querySelectorAll('#db-locations thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('db-locations-sort-' + column);
  if (indicator) indicator.textContent = dbSortState.locations.direction === 'asc' ? '▲' : '▼';
  
  renderDbLocations();
  filterDbLocations();
}

function filterDbSongs() {
  const search = document.getElementById('db-song-search').value.toLowerCase();
  const tbody = document.getElementById('db-songs-tbody');
  tbody.innerHTML = '';
  
  dbSongRows
    .filter(row => {
      // Filter out Chuck's Dream first
      const songNameLower = row.data.name.toLowerCase();
      const normLower = normalizeSongName(row.data.name).toLowerCase();
      
      if (songNameLower.includes("chuck's dream") || 
          songNameLower.includes("chucks dream") ||
          normLower.includes("chuck")) {
        return false;
      }
      
      // Then apply search filter
      return !search || row.data.name.toLowerCase().includes(search);
    })
    .forEach(row => tbody.appendChild(row.element));
}

function filterDbLocations() {
  const search = document.getElementById('db-location-search').value.toLowerCase();
  const tbody = document.getElementById('db-locations-tbody');
  tbody.innerHTML = '';
  
  dbLocationRows
    .filter(row => !search || 
      row.location.toLowerCase().includes(search) ||
      row.data.venue.toLowerCase().includes(search))
    .forEach(row => tbody.appendChild(row.element));
}

function searchDbPairing() {
  const song1 = document.getElementById('db-pair-song1').value.trim();
  const song2 = document.getElementById('db-pair-song2').value.trim();
  const resultsDiv = document.getElementById('db-pairing-results');
  
  if (!song1 || !song2) {
    resultsDiv.innerHTML = '<div class="result-box">Please enter both song names</div>';
    return;
  }
  
  const norm1 = normalizeSongName(song1);
  const norm2 = normalizeSongName(song2);
  const sequences = [];
  const coAppearances = [];
  
  dbDates.forEach(date => {
    const show = dbShows[date];
    const sets = show.sets || {};
    let foundSequence = false;
    let found1 = false, found2 = false;
    
    Object.values(sets).forEach(setContent => {
      const songs = parseDbSetlist(setContent);
      const normalized = songs.map(s => normalizeSongName(s));
      
      for (let i = 0; i < normalized.length - 1; i++) {
        if (normalized[i] === norm1 && normalized[i + 1] === norm2) {
          foundSequence = true;
          break;
        }
      }
      
      if (normalized.includes(norm1)) found1 = true;
      if (normalized.includes(norm2)) found2 = true;
    });
    
    if (foundSequence) {
      sequences.push({ date, venue: `${show.venue}, ${show.city}, ${show.state}` });
    } else if (found1 && found2) {
      coAppearances.push({ date, venue: `${show.venue}, ${show.city}, ${show.state}` });
    }
  });
  
  if (sequences.length > 0) {
    resultsDiv.innerHTML = `
      <div class="result-box">
        <strong>Found ${sequences.length} "${song1} → ${song2}" sequence(s):</strong><br><br>
        ${sequences.map(m => `${m.date} - ${m.venue}`).join('<br>')}
      </div>
    `;
  } else if (coAppearances.length > 0) {
    resultsDiv.innerHTML = `
      <div class="result-box">
        <strong>No direct sequences, but found ${coAppearances.length} show(s) with both songs:</strong><br><br>
        ${coAppearances.map(m => `${m.date} - ${m.venue}`).join('<br>')}
      </div>
    `;
  } else {
    resultsDiv.innerHTML = '<div class="result-box">No pairings or co-appearances found</div>';
  }
}

function calculateShowDateGap() {
  const date1Input = document.getElementById('db-gap-date1').value.trim();
  const date2Input = document.getElementById('db-gap-date2').value.trim();
  const resultDiv = document.getElementById('db-gap-result');
  
  if (!date1Input || !date2Input) {
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = 'Please enter both show dates';
    return;
  }
  
  // Validate and normalize dates
  const normalizeDate = (dateStr) => {
    // Try to parse the date in various formats
    if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
      return dateStr; // Already in correct format
    } else if (dateStr.match(/^\d{1,2}[-\/]\d{1,2}[-\/]\d{4}$/)) {
      // Convert MM-DD-YYYY or MM/DD/YYYY to YYYY-MM-DD
      const parts = dateStr.split(/[-\/]/);
      const month = parts[0].padStart(2, '0');
      const day = parts[1].padStart(2, '0');
      const year = parts[2];
      return `${year}-${month}-${day}`;
    }
    return null;
  };
  
  const date1 = normalizeDate(date1Input);
  const date2 = normalizeDate(date2Input);
  
  if (!date1 || !date2) {
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = 'Invalid date format. Please use YYYY-MM-DD format (e.g., 2024-01-15)';
    return;
  }
  
  // Check if both dates exist in the database
  if (!dbShows[date1]) {
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = `No show found for ${date1}`;
    return;
  }
  
  if (!dbShows[date2]) {
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = `No show found for ${date2}`;
    return;
  }
  
  // Get show info
  const show1 = dbShows[date1];
  const show2 = dbShows[date2];
  
  // Determine which is earlier
  const earlierDate = new Date(date1) < new Date(date2) ? date1 : date2;
  const laterDate = new Date(date1) < new Date(date2) ? date2 : date1;
  const earlierShow = earlierDate === date1 ? show1 : show2;
  const laterShow = laterDate === date1 ? show1 : show2;
  
  // Calculate gaps
  const index1 = dbDates.indexOf(earlierDate);
  const index2 = dbDates.indexOf(laterDate);
  const showGap = index2 - index1 - 1;
  const dayGap = Math.floor((new Date(laterDate) - new Date(earlierDate)) / (1000 * 60 * 60 * 24));
  
  // Format dates for display
  const formatDate = (dateStr) => {
    const [year, month, day] = dateStr.split('-').map(Number);
    return new Date(year, month - 1, day).toLocaleDateString('en-US', {
      month: 'long',
      day: 'numeric',
      year: 'numeric'
    });
  };
  
  resultDiv.style.display = 'block';
  resultDiv.innerHTML = `<strong>SHOW GAP ANALYSIS</strong>

Earlier Show: ${formatDate(earlierDate)}
Venue:        ${earlierShow.venue}
Location:     ${earlierShow.city}, ${earlierShow.state}
${earlierShow.tour ? `Tour:         ${earlierShow.tour}` : ''}

Later Show:   ${formatDate(laterDate)}
Venue:        ${laterShow.venue}
Location:     ${laterShow.city}, ${laterShow.state}
${laterShow.tour ? `Tour:         ${laterShow.tour}` : ''}

<strong>GAP:</strong>
Shows:        ${showGap} show${showGap !== 1 ? 's' : ''} between
Days:         ${dayGap} days`;
}

function showLocationShows(type, value) {
  // Switch to stats page first
  switchPageByName('stats');
  
  let shows = [];
  let title = '';
  
  // Find shows based on location type
  if (type === 'cityState') {
    // Extract city and state if possible
    const [city, state] = value.split(',').map(s => s.trim());
    shows = dbDates.filter(date => {
      const show = dbShows[date];
      if (state) {
        return show.city === city && show.state === state;
      } else {
        return show.city === value || `${show.city}, ${show.state}` === value;
      }
    });
    title = `Shows in ${value}`;
  } else if (type === 'venue') {
    shows = dbDates.filter(date => {
      const show = dbShows[date];
      return show.venue === value;
    });
    title = `Shows at ${value}`;
  }
  
  // Update header info
  document.getElementById('song-detail-title').textContent = title;
  document.getElementById('song-detail-count').textContent = shows.length;
  document.getElementById('song-detail-first').textContent = shows[0] || '-';
  document.getElementById('song-detail-last').textContent = shows[shows.length - 1] || '-';
  document.getElementById('song-detail-gap').textContent = '-';
  
  // Clear the new song search input
  document.getElementById('song-detail-new-search').value = '';
  
  // Render location shows table
  renderLocationShowsTable(shows, title);
  
  // Switch to song detail tab (we're repurposing it for location shows)
  switchDbTab('song-detail');
}

function renderLocationShowsTable(shows, title) {
  const tbody = document.getElementById('song-detail-tbody');
  tbody.innerHTML = '';
  
  if (shows.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;padding:2rem;color:var(--muted-color);">No shows found</td></tr>';
    return;
  }
  
  // Sort shows by date (newest first)
  shows.sort((a, b) => new Date(b) - new Date(a));
  
  shows.forEach(date => {
    const show = dbShows[date];
    if (!show) return;
    
    // Count total songs in the show
    let totalSongs = 0;
    const sets = show.sets || {};
    Object.values(sets).forEach(setContent => {
      const songs = parseDbSetlist(setContent);
      totalSongs += songs.length;
    });
    
    // Count jam chart entries for this show
    const jamEntries = allJams.filter(jam => {
      const jamDbDate = jam.dbDate || (jam.date.includes('-') && jam.date.split('-')[0].length === 4 
        ? jam.date 
        : (() => {
            const [m, d, y] = jam.date.split('-');
            return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
          })());
      return jamDbDate === date;
    });
    
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter date-link" data-date="${date}" style="cursor: pointer; color: var(--text-color);">${date}</span></td>
      <td><span class="clickable-filter">${show.venue || 'Unknown'}</span></td>
      <td>${show.city || 'Unknown'}, ${show.state || ''}</td>
      <td>${totalSongs}</td>
      <td>${jamEntries.length}</td>
      <td>${show.tour || '-'}</td>
      <td>${show.show_number || '-'}</td>
    `;
    
    tbody.appendChild(tr);
  });
  
  // Update the table headers for location shows
  const thead = document.querySelector('#db-song-detail thead tr');
  thead.innerHTML = `
    <th onclick="sortLocationShows('date')">Date <span id="location-shows-date-sort">▼</span></th>
    <th onclick="sortLocationShows('venue')">Venue <span id="location-shows-venue-sort"></span></th>
    <th onclick="sortLocationShows('location')">Location <span id="location-shows-location-sort"></span></th>
    <th onclick="sortLocationShows('songs')">Total Songs <span id="location-shows-songs-sort"></span></th>
    <th onclick="sortLocationShows('jams')">Jam Entries <span id="location-shows-jams-sort"></span></th>
    <th onclick="sortLocationShows('tour')">Tour <span id="location-shows-tour-sort"></span></th>
    <th onclick="sortLocationShows('showNumber')">Show # <span id="location-shows-showNumber-sort"></span></th>
  `;
}

function sortLocationShows(column) {
  const tbody = document.getElementById('song-detail-tbody');
  const rows = Array.from(tbody.querySelectorAll('tr'));
  
  rows.sort((a, b) => {
    let aValue, bValue;
    
    switch (column) {
      case 'date':
        aValue = new Date(a.cells[0].textContent);
        bValue = new Date(b.cells[0].textContent);
        break;
      case 'venue':
        aValue = a.cells[1].textContent.toLowerCase();
        bValue = b.cells[1].textContent.toLowerCase();
        break;
      case 'location':
        aValue = a.cells[2].textContent.toLowerCase();
        bValue = b.cells[2].textContent.toLowerCase();
        break;
      case 'songs':
        aValue = parseInt(a.cells[3].textContent) || 0;
        bValue = parseInt(b.cells[3].textContent) || 0;
        break;
      case 'jams':
        aValue = parseInt(a.cells[4].textContent) || 0;
        bValue = parseInt(b.cells[4].textContent) || 0;
        break;
      case 'tour':
        aValue = a.cells[5].textContent.toLowerCase();
        bValue = b.cells[5].textContent.toLowerCase();
        break;
      case 'showNumber':
        aValue = parseInt(a.cells[6].textContent) || 0;
        bValue = parseInt(b.cells[6].textContent) || 0;
        break;
    }
    
    if (typeof aValue === 'number') {
      return aValue - bValue;
    } else {
      return aValue.localeCompare(bValue);
    }
  });
  
  // Clear and re-append sorted rows
  tbody.innerHTML = '';
  rows.forEach(row => tbody.appendChild(row));
  
  // Update sort indicators
  document.querySelectorAll('#db-song-detail thead th span').forEach(span => span.textContent = '');
  const indicator = document.getElementById('location-shows-' + column + '-sort');
  if (indicator) indicator.textContent = '▼';
}

// Add click handlers for stats tables
document.addEventListener('click', e => {
  const target = e.target.closest('.clickable-filter');
  if (!target) return;
  
  // Check if we're in the stats page
  const statsPage = document.getElementById('page-stats');
  if (statsPage.style.display !== 'none') {
    const text = target.textContent.trim();
    
    // Check if this is a date (matches YYYY-MM-DD or MM-DD-YYYY format)
    const isDate = /^\d{4}-\d{2}-\d{2}$/.test(text) || /^\d{1,2}-\d{1,2}-\d{4}$/.test(text);
    
    if (isDate) {
      // Always show setlist for date clicks in stats
      showSetlistForDate(text);
      return;
    }
    
    // Check if this is a song name click in the song history table
    const isSongInHistoryTable = target.closest('#db-songs-tbody') && 
                                 target.closest('td') && 
                                 target.closest('td').cellIndex === 0; // First column (song names)
    
    if (isSongInHistoryTable) {
      // This is a song name click in the song history table - show song detail
      const norm = target.getAttribute('data-song-norm');
      if (norm) {
        showSongDetail(norm);
      } else {
        // Fallback: try to find the song by name
        const songNorm = normalizeSongName(text);
        if (dbSongs[songNorm]) {
          showSongDetail(songNorm);
        } else {
          // If not found, search for it
          switchPageByName('jams');
          document.getElementById('search-input').value = text;
          renderFilteredJams();
        }
      }
      return;
    }
    
    // NEW: Check if this is a location click (city, state, or venue)
    const isLocationClick = target.closest('#db-locations-tbody');
    if (isLocationClick) {
      const row = target.closest('tr');
      const locationText = target.textContent.trim();
      const cellIndex = target.closest('td').cellIndex;
      
      // Determine what type of location was clicked
      if (cellIndex === 0) { // City, State column
        showLocationShows('cityState', locationText);
      } else if (cellIndex === 1) { // Venue column
        showLocationShows('venue', locationText);
      } else if (cellIndex === 3 || cellIndex === 4) { // First/Last show dates
        showSetlistForDate(text);
      }
      return;
    }
// For all other clicks in stats page, do the regular search
    switchPageByName('jams');
    document.getElementById('search-input').value = text;
    renderFilteredJams();
  }
});

function showSongDetail(normSongName) {
  // Switch back to stats page first
  switchPageByName('stats');
  
  const song = dbSongs[normSongName];
  if (!song) {
    console.log("❌ Song not found in dbSongs:", normSongName);
    return;
  }
  
  console.log("🔄 showSongDetail called with:", normSongName);
  console.log("Song data:", song);
  
  currentSongDetail = { norm: normSongName, data: song };
  
  // Update header info
  document.getElementById('song-detail-title').textContent = song.name;
  document.getElementById('song-detail-count').textContent = song.performances.length;
  document.getElementById('song-detail-first').textContent = song.firstPlayed;
  document.getElementById('song-detail-last').textContent = song.lastPlayed;
  
  const lastIdx = dbDates.indexOf(song.lastPlayed);
  const currentGap = dbDates.length - 1 - lastIdx;
  document.getElementById('song-detail-gap').textContent = currentGap;
  
  // Clear the new song search input
  document.getElementById('song-detail-new-search').value = '';
  
  // Render performance table
  renderSongDetailTable();
  
  // Switch to song detail tab
  switchDbTab('song-detail');
}

function renderSongDetailTable() {
  if (!currentSongDetail) return;
  
  const tbody = document.getElementById('song-detail-tbody');
  tbody.innerHTML = '';
  
  const song = currentSongDetail.data;
  
  // Get ALL performance dates (including duplicates for multiple shows on same date)
  const allPerformanceDates = song.performances;
  
  let performances = [];
  let processedDates = new Set(); // Track which date+show combinations we've processed

  // Build performances - process ALL occurrences
  allPerformanceDates.forEach((baseDate, dateIndex) => {
    // Try to find ALL shows for this base date (could be multiple shows on same date)
    const showsForDate = Object.keys(dbShows).filter(key => {
      const keyBaseDate = key.split('/')[0];
      return keyBaseDate === baseDate;
    }).sort(); // Sort to ensure consistent order

    showsForDate.forEach(showKey => {
      const show = dbShows[showKey];
      if (!show) return;
      
      const sets = show.sets || {};
      
      // Find ALL occurrences of this song in this specific show
      Object.entries(sets).forEach(([setName, setContent]) => {
        const songs = parseDbSetlist(setContent);
        
        songs.forEach((songName, idx) => {
          let norm = normalizeSongName(songName);
          
          // SPECIAL HANDLING: Apply the same normalization as in processShowsDatabase
          if (norm.includes("to be young") || norm.includes("is to be high") || norm.includes("is to be sad")) {
            norm = "to be young is to be sad is to be high";
          }
          
          if (norm === currentSongDetail.norm) {
            // Create unique identifier for this performance
            const performanceId = `${showKey}-${setName}-${idx}`;
            
            // Skip if we've already processed this exact performance
            if (processedDates.has(performanceId)) return;
            processedDates.add(performanceId);
            
            // Standardize set name
            let standardizedSetName = setName;
            if (setName.toLowerCase().includes('set1') || setName === '1') {
              standardizedSetName = 'Set 1';
            } else if (setName.toLowerCase().includes('set2') || setName === '2') {
              standardizedSetName = 'Set 2';
            } else if (setName.toLowerCase().includes('set3') || setName === '3') {
              standardizedSetName = 'Set 3';
            } else if (setName.toLowerCase().includes('encore')) {
              standardizedSetName = 'Encore';
            } else {
              standardizedSetName = setName.replace('set', 'Set ');
            }
            
            // Calculate gap from previous performance
            let gap = '-';
            if (dateIndex === 0 && performances.length === 0) {
              // First ever performance - calculate shows from beginning
              let currentDateIndex = dbDates.indexOf(showKey);
              if (currentDateIndex === -1) {
                // If not found, try to find the position by date comparison
                currentDateIndex = dbDates.findIndex(d => new Date(d.split('/')[0]) >= new Date(baseDate));
              }
              gap = currentDateIndex >= 0 ? currentDateIndex : 0;
            } else if (performances.length > 0) {
              // Get the previous performance's show key
              const prevPerformance = performances[performances.length - 1];
              const prevShowKey = prevPerformance.showKey;
              
              // Only show gap if this is a different show than previous
              if (showKey !== prevShowKey) {
                let currentDateIndex = dbDates.indexOf(showKey);
                let prevDateIndex = dbDates.indexOf(prevShowKey);
                
                // If exact keys not found, find closest matches
                if (currentDateIndex === -1 || prevDateIndex === -1) {
                  // Fallback: calculate by date comparison
                  const currentDate = new Date(baseDate);
                  const prevDate = new Date(prevPerformance.baseDate);
                  const allSortedDates = [...new Set(dbDates.map(d => d.split('/')[0]))].sort((a, b) => new Date(a) - new Date(b));
                  const currentSortedIndex = allSortedDates.indexOf(baseDate);
                  const prevSortedIndex = allSortedDates.indexOf(prevPerformance.baseDate);
                  
                  if (currentSortedIndex !== -1 && prevSortedIndex !== -1) {
                    gap = Math.max(0, currentSortedIndex - prevSortedIndex - 1);
                  }
                } else {
                  gap = Math.max(0, currentDateIndex - prevDateIndex - 1);
                }
              } else {
                gap = ''; // Same show as previous performance, no gap
              }
            }
            
            performances.push({
              baseDate,
              showKey,
              dateTimestamp: new Date(baseDate).getTime(),
              chronologicalIndex: performances.length,
              show,
              setName: standardizedSetName,
              position: idx,
              songBefore: idx > 0 ? songs[idx - 1].replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, '') : '-',
              songAfter: idx < songs.length - 1 ? songs[idx + 1].replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, '') : '-',
              gap: gap
            });
          }
        });
      });
    });
  });
  
  // Apply sorting
  const sort = dbSortState.songDetail;
  performances.sort((a, b) => {
    let result = 0;
    
    if (sort.column === 'date') {
      result = a.dateTimestamp - b.dateTimestamp;
      if (result === 0) {
        const setOrder = {'Set 1': 1, 'Set 2': 2, 'Set 3': 3, 'Encore': 4};
        result = (setOrder[a.setName] || 5) - (setOrder[b.setName] || 5);
        if (result === 0) {
          result = a.position - b.position;
        }
      }
    } else if (sort.column === 'venue') {
      const va = (a.show.venue || '').toLowerCase();
      const vb = (b.show.venue || '').toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    } else if (sort.column === 'gap') {
      const va = (a.gap === '-' || a.gap === '') ? -1 : parseInt(a.gap);
      const vb = (b.gap === '-' || b.gap === '') ? -1 : parseInt(b.gap);
      result = va - vb;
    } else if (sort.column === 'set') {
      const setOrder = {'Set 1': 1, 'Set 2': 2, 'Set 3': 3, 'Encore': 4};
      result = (setOrder[a.setName] || 5) - (setOrder[b.setName] || 5);
      if (result === 0) {
        result = a.position - b.position;
      }
    } else if (sort.column === 'songBefore') {
      const va = a.songBefore.toLowerCase();
      const vb = b.songBefore.toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    } else if (sort.column === 'songAfter') {
      const va = a.songAfter.toLowerCase();
      const vb = b.songAfter.toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    }
    
    return sort.direction === 'asc' ? result : -result;
  });
  
  // IMPROVED JAM MATCHING LOGIC
  const jamsForSong = allJams.filter(j => {
    const jamNorm = normalizeSongName(j.song);
    const dbNorm = currentSongDetail.norm;
    
    if (jamNorm === dbNorm) return true;
    
    if ((jamNorm.includes("to be young") || jamNorm.includes("is to be high") || jamNorm.includes("is to be sad")) &&
        (dbNorm.includes("to be young") || dbNorm.includes("is to be high") || dbNorm.includes("is to be sad"))) {
      return true;
    }
    
    if (jamNorm.includes(dbNorm) || dbNorm.includes(jamNorm)) {
      return true;
    }
    
    return false;
  });
  
  // Render each performance
  performances.forEach(perf => {
    const jamEntry = jamsForSong.find(j => {
      const jamDate = j.date;
      const formattedJamDate = formatDateForDisplay(jamDate);
      const perfBaseDate = perf.baseDate;
      
      return jamDate === perfBaseDate || 
             formattedJamDate === perfBaseDate ||
             formatDateForDisplay(perfBaseDate) === jamDate ||
             formatDateForDisplay(perfBaseDate) === formattedJamDate;
    });
    
    const isHighlighted = jamEntry?.highlighted;
    const notes = jamEntry?.notes || '-';
    
    const tr = document.createElement('tr');
    if (isHighlighted) tr.classList.add('highlighted-row');
    
    // Create venue click handler
    const venueCell = `<span class="clickable-venue" data-venue="${perf.show.venue || 'Unknown'}" style="cursor: pointer; color: var(--yellow);">${perf.show.venue || 'Unknown'}</span>`;
    
    // Create song before/after click handlers
    const songBeforeCell = perf.songBefore !== '-' 
      ? `<span class="clickable-song-history" data-song="${perf.songBefore}" style="cursor: pointer; color: var(--yellow);">${perf.songBefore}</span>`
      : '-';
    
    const songAfterCell = perf.songAfter !== '-' 
      ? `<span class="clickable-song-history" data-song="${perf.songAfter}" style="cursor: pointer; color: var(--yellow);">${perf.songAfter}</span>`
      : '-';
    
    tr.innerHTML = `
      <td><span class="clickable-filter date-link" data-date="${perf.baseDate}" style="cursor: pointer; color: var(--text-color); ${isHighlighted ? 'font-weight:bold;' : ''}">${perf.baseDate}</span></td>
      <td>${venueCell}</td>
      <td>${perf.gap}</td>
      <td>${perf.setName}</td>
      <td>${songBeforeCell}</td>
      <td>${songAfterCell}</td>
      <td>${notes}</td>
    `;
    
    tbody.appendChild(tr);
  });
  
  // Add click event listeners for the new elements
  setTimeout(() => {
    // Venue clicks - show venue stats
    document.querySelectorAll('.clickable-venue').forEach(venueElement => {
      venueElement.addEventListener('click', function(e) {
        e.stopPropagation();
        const venueName = this.getAttribute('data-venue');
        console.log('Venue clicked:', venueName);
        showLocationShows('venue', venueName);
      });
    });
    
    // Song before/after clicks - show song history
    document.querySelectorAll('.clickable-song-history').forEach(songElement => {
      songElement.addEventListener('click', function(e) {
        e.stopPropagation();
        const songName = this.getAttribute('data-song');
        console.log('Song clicked:', songName);
        
        // Find the song in the database
        const normSearch = normalizeSongName(songName);
        if (dbSongs[normSearch]) {
          showSongDetail(normSearch);
        } else {
          // If not found, search for similar songs
          const similarSong = Object.keys(dbSongs).find(songKey => 
            normalizeSongName(songKey).includes(normSearch) || 
            normSearch.includes(normalizeSongName(songKey))
          );
          
          if (similarSong) {
            showSongDetail(similarSong);
          } else {
            console.log(`Song "${songName}" not found in database`);
            // Fallback: search in the main song list
            document.getElementById('db-song-search').value = songName;
            switchDbTab('songs');
            filterDbSongs();
          }
        }
      });
    });
  }, 0);
  
  console.log('About to render', performances.length, 'performances');
  console.log('First 3 performances:', performances.slice(0, 3));
  
  if (performances.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;padding:2rem;color:var(--muted-color);">No performances found in setlists for this song</td></tr>';
  }
}

function sortSongDetail(column) {
  if (dbSortState.songDetail.column === column) {
    dbSortState.songDetail.direction = dbSortState.songDetail.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.songDetail.column = column;
    dbSortState.songDetail.direction = 'asc';
  }
  
  document.querySelectorAll('#db-song-detail thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('song-detail-' + column + '-sort');
  if (indicator) indicator.textContent = dbSortState.songDetail.direction === 'asc' ? '▲' : '▼';
  
  renderSongDetailTable();
}

function filterSongDetail() {
  const search = document.getElementById('song-detail-search').value.toLowerCase();
  const allRows = document.querySelectorAll('#song-detail-tbody tr');
  
  allRows.forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(search) ? '' : 'none';
  });
}

function searchNewSongFromDetail() {
  const searchValue = document.getElementById('song-detail-new-search').value.trim();
  if (!searchValue) return;
  
  // Find the song in the database
  const normSearch = normalizeSongName(searchValue);
  const song = dbSongs[normSearch];
  
  if (song) {
    // Show the song detail for the new song
    showSongDetail(normSearch);
  } else {
    // If not found, search in the main song list and switch to song history
    document.getElementById('db-song-search').value = searchValue;
    switchDbTab('songs');
    filterDbSongs();
  }
}

function switchPageByName(page) {
  document.querySelectorAll('.page-tab').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.page-content').forEach(pane => pane.style.display = 'none');
  
  document.querySelector(`.page-tab[onclick="switchPage('${page}')"]`).classList.add('active');
  document.getElementById('page-' + page).style.display = 'block';
}

function switchDbTab(tab) {
  document.querySelectorAll('.tab-button:not(.page-tab)').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
  
  if (event && event.target) {
    event.target.classList.add('active');
  } else {
    document.querySelector(`.tab-button[onclick*="${tab}"]`).classList.add('active');
  }
  document.getElementById('db-' + tab).classList.add('active');
  
  // Reset song detail table headers when switching away from song-detail tab
  if (tab !== 'song-detail' && currentSongDetail) {
    const thead = document.querySelector('#db-song-detail thead tr');
    thead.innerHTML = `
      <th onclick="sortSongDetail('date')">Date <span id="song-detail-date-sort">▲</span></th>
      <th onclick="sortSongDetail('venue')">Venue <span id="song-detail-venue-sort"></span></th>
      <th onclick="sortSongDetail('gap')">Gap <span id="song-detail-gap-sort"></span></th>
      <th onclick="sortSongDetail('set')">Set <span id="song-detail-set-sort"></span></th>
      <th onclick="sortSongDetail('songBefore')">Song Before</th>
      <th onclick="sortSongDetail('songAfter')">Song After</th>
      <th>Notes</th>
    `;
  }
}

// Add random show function
function showRandomSetlist() {
  const allDates = Object.keys(dbShows).filter(d => d.match(/^\d{4}-\d{2}-\d{2}/));
  const randomDate = allDates[Math.floor(Math.random() * allDates.length)];
  showSetlistForDate(randomDate);
}

function showLocationShows(type, value) {
  // Switch to stats page first
  switchPageByName('stats');
  
  let shows = [];
  let title = '';
  
  // Find shows based on location type
  if (type === 'cityState') {
    shows = dbDates.filter(date => {
      const show = dbShows[date];
      return `${show.city}, ${show.state}` === value;
    });
    title = `Shows in ${value}`;
  } else if (type === 'venue') {
    shows = dbDates.filter(date => {
      const show = dbShows[date];
      return show.venue === value;
    });
    title = `Shows at ${value}`;
  }
  
  // Update header info
  document.getElementById('song-detail-title').textContent = title;
  document.getElementById('song-detail-count').textContent = shows.length;
  document.getElementById('song-detail-first').textContent = shows[0] || '-';
  document.getElementById('song-detail-last').textContent = shows[shows.length - 1] || '-';
  document.getElementById('song-detail-gap').textContent = '-';
  
  // Clear the new song search input
  document.getElementById('song-detail-new-search').value = '';
  
  // Render location shows table
  renderLocationShowsTable(shows, title);
  
  // Switch to song detail tab
  switchDbTab('song-detail');
}

function renderLocationShowsTable(shows, title) {
  const tbody = document.getElementById('song-detail-tbody');
  tbody.innerHTML = '';
  
  if (shows.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;padding:2rem;color:var(--muted-color);">No shows found</td></tr>';
    return;
  }
  
  // Sort shows by date (newest first)
  shows.sort((a, b) => new Date(b) - new Date(a));
  
  shows.forEach(date => {
    const show = dbShows[date];
    if (!show) return;
    
    // Count total songs in the show
    let totalSongs = 0;
    const sets = show.sets || {};
    Object.values(sets).forEach(setContent => {
      const songs = parseDbSetlist(setContent);
      totalSongs += songs.length;
    });
    
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter date-link" data-date="${date}" style="cursor: pointer; color: var(--text-color);">${date}</span></td>
      <td><span class="clickable-filter">${show.venue || 'Unknown'}</span></td>
      <td>${show.city || 'Unknown'}, ${show.state || ''}</td>
      <td>${totalSongs}</td>
      <td>${show.tour || '-'}</td>
      <td>${show.show_number || '-'}</td>
    `;
    
    tbody.appendChild(tr);
  });
  
  // Update the table headers for location shows
  const thead = document.querySelector('#db-song-detail thead tr');
  thead.innerHTML = `
    <th>Date</th>
    <th>Venue</th>
    <th>Location</th>
    <th>Total Songs</th>
    <th>Tour</th>
    <th>Show #</th>
  `;
}

function showLocationShows(type, value) {
  // Switch to stats page first
  switchPageByName('stats');
  
  let shows = [];
  let title = '';
  
  // Find shows based on location type
  if (type === 'cityState') {
    shows = dbDates.filter(date => {
      const show = dbShows[date];
      return `${show.city}, ${show.state}` === value;
    });
    title = `Shows in ${value}`;
  } else if (type === 'venue') {
    shows = dbDates.filter(date => {
      const show = dbShows[date];
      return show.venue === value;
    });
    title = `Shows at ${value}`;
  }
  
  // Update header info
  document.getElementById('song-detail-title').textContent = title;
  document.getElementById('song-detail-count').textContent = shows.length;
  document.getElementById('song-detail-first').textContent = shows[0] || '-';
  document.getElementById('song-detail-last').textContent = shows[shows.length - 1] || '-';
  document.getElementById('song-detail-gap').textContent = '-';
  
  // Clear the new song search input
  document.getElementById('song-detail-new-search').value = '';
  
  // Render location shows table
  renderLocationShowsTable(shows, title);
  
  // Switch to song detail tab
  switchDbTab('song-detail');
}

function renderLocationShowsTable(shows, title) {
  const tbody = document.getElementById('song-detail-tbody');
  tbody.innerHTML = '';
  
  if (shows.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;padding:2rem;color:var(--muted-color);">No shows found</td></tr>';
    return;
  }
  
  // Sort shows by date (newest first)
  shows.sort((a, b) => new Date(b) - new Date(a));
  
  shows.forEach(date => {
    const show = dbShows[date];
    if (!show) return;
    
    // Count total songs in the show
    let totalSongs = 0;
    const sets = show.sets || {};
    Object.values(sets).forEach(setContent => {
      const songs = parseDbSetlist(setContent);
      totalSongs += songs.length;
    });
    
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter date-link" data-date="${date}" style="cursor: pointer; color: var(--text-color);">${date}</span></td>
      <td><span class="clickable-filter">${show.venue || 'Unknown'}</span></td>
      <td>${show.city || 'Unknown'}, ${show.state || ''}</td>
      <td>${totalSongs}</td>
      <td>${show.tour || '-'}</td>
      <td>${show.show_number || '-'}</td>
    `;
    
    tbody.appendChild(tr);
  });
  
  // Update the table headers for location shows
  const thead = document.querySelector('#db-song-detail thead tr');
  thead.innerHTML = `
    <th>Date</th>
    <th>Venue</th>
    <th>Location</th>
    <th>Total Songs</th>
    <th>Tour</th>
    <th>Show #</th>
  `;
}
document.addEventListener('DOMContentLoaded', function() {
  // Define loadShowsDatabase function
  function loadShowsDatabase() {
    console.log('Loading shows_database.json...');
    fetch('shows_database.json')
      .then(r => {
        console.log('Shows database response:', r.status);
        if (!r.ok) throw new Error(`HTTP error! status: ${r.status}`);
        return r.json();
      })
      .then(data => {
        console.log('Shows database loaded:', Object.keys(data).length, 'shows');
        
        // Clean the date keys - normalize dates with /1, /2 suffixes
        const cleanedData = {};
        Object.keys(data).forEach(dateKey => {
          const cleanDate = dateKey.split('/')[0]; // Take only YYYY-MM-DD part
          
          // Store with clean key - if duplicate, keep the one WITHOUT suffix as primary
          if (!cleanedData[cleanDate] || !dateKey.includes('/')) {
            cleanedData[cleanDate] = data[dateKey];
          }
          
          // Also store the original key for lookup (for setlist display)
          cleanedData[dateKey] = data[dateKey];
        });
        
        dbShows = cleanedData;
        processShowsDatabase();
        renderDbSongs();
        renderDbLocations();
        loadJams();
      })
      .catch(err => {
        console.error('Failed to load shows_database.json:', err);
        document.getElementById('db-songs-tbody').innerHTML = 
          '<tr><td colspan="5" style="text-align:center;padding:2rem;color:var(--muted-color);">Failed to load shows_database.json</td></tr>';
      });
  }

  function processShowsDatabase() {
  const songs = {};
  const locations = {};
  dbDates = [];

  Object.keys(dbShows)
    .filter(d => /^\d{4}-\d{2}-\d{2}(?:\/\d+)?$/.test(d))
    .sort()
    .forEach(fullKey => {
      const baseDate = fullKey.split('/')[0]; // what we display
      const show = dbShows[fullKey];
      const venue = show.venue || "Unknown";
      const city = show.city || "Unknown";
      const state = show.state || "";
      const locationKey = `${city}, ${state}`.trim();

      // track this show by full key (so we don’t lose multi-shows)
      dbDates.push(fullKey);

      // Locations table still groups by base date
      if (!locations[locationKey]) {
        locations[locationKey] = {
          venue,
          shows: [],
          firstShow: baseDate,
          lastShow: baseDate,
        };
      }
      locations[locationKey].shows.push(baseDate);
      if (new Date(baseDate) < new Date(locations[locationKey].firstShow))
        locations[locationKey].firstShow = baseDate;
      if (new Date(baseDate) > new Date(locations[locationKey].lastShow))
        locations[locationKey].lastShow = baseDate;

      // Parse sets → songs
         const sets = show.sets || {};
    Object.entries(sets).forEach(([setName, setContent]) => {
      // SKIP CHUCK'S DREAM SECTIONS ENTIRELY
      if (setName.toLowerCase().includes("chuck's dream")) {
        return;
      }
      const songList = parseDbSetlist(setContent);
        songList.forEach(song => {
          let norm = normalizeSongName(song);
          let displayName = song.trim()
            .replace(/^[\s|]+/, "")
            .replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, "")
            .replace(/\s*\(\s*[\d:\-]+\s*\)\s*/g, "")
            .replace(/[,\s]+$/, "")
            .trim();

          // merge variants
          if (norm.includes("to be young") || norm.includes("is to be high") || norm.includes("is to be sad")) {
            norm = "to be young is to be sad is to be high";
            displayName = "To Be Young (Is to Be Sad, Is to Be High)";
          }
          if (norm.includes("april 29 1992 miami")) displayName = "April 29, 1992 (Miami)";
          else if (norm.includes("smooth relax down")) displayName = "Smooth, Relax, Down";
          else if (norm.includes("motel 6")) displayName = "Motel 6";

          if (!songs[norm]) {
            songs[norm] = {
              name: displayName,
              performances: [],
              firstPlayed: baseDate,
              lastPlayed: baseDate,
            };
          }

          // push baseDate for display but keep reference to fullKey internally
          songs[norm].performances.push(baseDate);
          songs[norm].performances = [...new Set(songs[norm].performances)];

          if (new Date(baseDate) < new Date(songs[norm].firstPlayed))
            songs[norm].firstPlayed = baseDate;
          if (new Date(baseDate) > new Date(songs[norm].lastPlayed))
            songs[norm].lastPlayed = baseDate;
        });
      });
    });

  // Merge duplicates
  const merged = {};
  Object.values(songs).forEach(song => {
    const key = normalizeSongName(song.name).replace(/[^\w\s]/g, "").trim();
    if (!key) return;

    if (!merged[key]) {
      merged[key] = { ...song };
    } else {
      merged[key].performances.push(...song.performances);
      merged[key].performances = [...new Set(merged[key].performances)].sort(
        (a, b) => new Date(a) - new Date(b)
      );
      if (new Date(song.firstPlayed) < new Date(merged[key].firstPlayed))
        merged[key].firstPlayed = song.firstPlayed;
      if (new Date(song.lastPlayed) > new Date(merged[key].lastPlayed))
        merged[key].lastPlayed = song.lastPlayed;
    }
  });

  dbSongs = merged;
  dbLocations = locations;

  // total shows includes all variants (so 980 stays 980)
  document.getElementById("db-total-songs").textContent = Object.keys(merged).length;
  document.getElementById("db-total-shows").textContent = dbDates.length;
}


  // Now call the function
  loadShowsDatabase();
});
</script>
</body>
</html>
