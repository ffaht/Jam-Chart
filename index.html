<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spafford Jam Chart</title>
<style>
:root {
  --bg-color:#000;
  --card-bg:#111;
  --text-color:#f0f0f0;
  --muted-color:#999;
  --border-color:#222;
  --yellow:#ffeb3b;
  --accent-color:#b0b0b0;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:var(--bg-color);color:var(--text-color);min-height:100vh;}
.container{max-width:1200px;margin:0 auto;padding:20px;}
.site-header{text-align:center;padding:2rem 0;margin-bottom:2rem;}
.site-header h1{font-size:2.5rem;margin-bottom:0.5rem;}
.site-header p{color:var(--muted-color);}
.site-disclaimer{font-size:0.85rem;font-style:italic;margin-top:0.5rem;}
.search-container{display:flex;gap:1rem;margin-bottom:2rem;align-items:center;}
#search-input{flex:1;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
#filter-select{padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);}
.search-container input[type="text"]{flex:1;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
.jam-table-container{background:var(--card-bg);border-radius:8px;border:1px solid var(--border-color);overflow-x:auto;}
.jam-table{width:100%;border-collapse:collapse;font-size:0.9rem;}
.jam-table th:first-child,
.jam-table td:first-child{width:95px;min-width:95px;white-space:nowrap;}
.jam-table th{background:#0a0a0a;color:var(--text-color);font-weight:600;padding:1rem 0.75rem;text-align:left;border-bottom:2px solid var(--border-color);cursor:pointer;user-select:none;}
.jam-table th:hover{background:#151515;}
.jam-table td{padding:0.75rem;border-bottom:1px solid var(--border-color);line-height:1.4;vertical-align:top;}
.jam-table tr:hover{background:rgba(255,255,255,0.02);}
.jam-entry{cursor:pointer;color:var(--yellow);}
.jam-entry.highlighted{font-weight:bold;}
.highlighted-row{border-left:4px solid var(--yellow);}
.selected-row{box-shadow:0 0 0 2px rgba(255,235,59,0.3);}
.clickable-filter{cursor:pointer;transition:all 0.2s ease;color:var(--yellow);}
.clickable-filter:hover{text-decoration:underline;color:var(--accent-color);}
.status-message{text-align:center;padding:0.5rem;border-radius:4px;font-weight:bold;}
.status-message.success{color:#28a745;}
.status-message.error{color:#dc3545;}
.status-message.info{color:#17a2b8;}

/* Database Explorer Styles */
.tab-nav{display:flex;gap:0.5rem;margin-bottom:1.5rem;flex-wrap:wrap;}
.tab-button{padding:0.6rem 1.2rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);cursor:pointer;transition:all 0.2s;font-size:0.9rem;}
.tab-button:hover{background:#1a1a1a;}
.tab-button.active{background:#2a2a2a;border-color:var(--yellow);font-weight:600;}
.tab-pane{display:none;}
.tab-pane.active{display:block;}
.mini-stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:1rem;margin-bottom:1.5rem;}
.mini-stat{background:var(--card-bg);padding:1rem;border-radius:6px;border:1px solid var(--border-color);text-align:center;}
.mini-stat-value{font-size:1.8rem;font-weight:bold;color:var(--yellow);}
.mini-stat-label{color:var(--muted-color);font-size:0.85rem;margin-top:0.3rem;}
.input-group{display:flex;gap:0.5rem;margin-bottom:1rem;flex-wrap:wrap;align-items:center;}
.input-group input,.input-group select{flex:1;min-width:200px;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
.btn-search{padding:0.75rem 1.5rem;border-radius:6px;border:none;background:var(--yellow);color:#000;font-weight:600;cursor:pointer;transition:all 0.2s;}
.btn-search:hover{background:#ffd700;}
.result-box{background:#1a1a1a;padding:1.5rem;border-radius:6px;margin-top:1rem;white-space:pre-line;line-height:1.6;}
.page-content{display:block;}

/* Setlist Modal Styles */
.setlist-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.setlist-content {
  background: var(--card-bg);
  border: 2px solid var(--yellow);
  border-radius: 8px;
  padding: 2rem;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
  color: var(--text-color);
}

.setlist-header {
  margin-bottom: 1.5rem;
}

.setlist-date {
  color: var(--text-color);
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
}

.setlist-venue {
  color: var(--muted-color);
  font-size: 1.1rem;
  margin-bottom: 0.25rem;
}

.setlist-show-info {
  color: var(--muted-color);
  font-size: 0.9rem;
  margin-bottom: 1rem;
}

.setlist-section {
  margin-bottom: 1.5rem;
}

.setlist-section-title {
  color: var(--text-color);
  font-weight: bold;
  margin-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 0.25rem;
}

.setlist-songs {
  color: var(--text-color);
  line-height: 1.6;
}

.setlist-song {
  margin-bottom: 0.5rem;
}

.setlist-arrow {
  color: var(--text-color);
  margin: 0 0.25rem;
  font-weight: normal;
}

.setlist-notes {
  color: var(--text-color);
  line-height: 1.6;
  font-style: italic;
  border-left: 3px solid var(--yellow);
  padding-left: 1rem;
  margin-top: 1rem;
}

.setlist-close {
  background: var(--yellow);
  color: #000;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  margin-top: 1rem;
  width: 100%;
}

.setlist-close:hover {
  background: #ffd700;
}

/* Date links in table */
.date-link {
  cursor: pointer;
  text-decoration: none;
  color: var(--text-color) !important;
}

.date-link:hover {
  color: var(--yellow) !important;
}

@media(max-width:768px){.container{padding:15px;}.site-header h1{font-size:2rem;}}
</style>
</head>
<body>
<header class="site-header">
<div class="container">
<h1>Spafford Jam Chart</h1>
<p>😀 😂 😊 😎 😜</p>
<p class="site-disclaimer">Some entries may display as incomplete - working on that!</p>
<div class="tab-nav" style="margin-top:1.5rem;justify-content:center;">
  <button class="tab-button page-tab active" onclick="switchPage('jams')">Jam Chart</button>
  <button class="tab-button page-tab" onclick="switchPage('stats')">Stats</button>
</div>
</div>
</header>
<main class="container">
<div id="page-jams" class="page-content">
<div class="search-container">
<input type="text" id="search-input" placeholder="Search songs, locations, dates..." onkeyup="renderFilteredJams()">
<select id="filter-select" onchange="renderFilteredJams()">
  <option value="all">All Jams</option>
  <option value="highlighted">Highlighted</option>
</select>
</div>
<div class="jam-table-container">
<table class="jam-table">
<thead>
<tr>
<th onclick="sortTable('date')">Date <span id="date-sort">▼</span></th>
<th onclick="sortTable('song')">Song <span id="song-sort"></span></th>
<th onclick="sortTable('timing')">Timing <span id="timing-sort"></span></th>
<th onclick="sortTable('venue')">Location <span id="venue-sort"></span></th>
<th onclick="sortTable('notes')">Notes <span id="notes-sort"></span></th>
</tr>
</thead>
<tbody id="jam-table-body"></tbody>
</table>
</div>
</div>

<div id="page-stats" class="page-content" style="display:none;">
<div style="margin-bottom:2rem;">
  <h2 style="margin-bottom:1.5rem;">Database Stats</h2>
  
  <div class="tab-nav">
    <button class="tab-button active" onclick="switchDbTab('songs')">Song History</button>
    <button class="tab-button" onclick="switchDbTab('pairings')">Song Pairings</button>
    <button class="tab-button" onclick="switchDbTab('locations')">Locations</button>
    <button class="tab-button" onclick="switchDbTab('gaps')">Gap Calculator</button>
  </div>

  <div id="db-songs" class="tab-pane active">
    <div class="mini-stats">
      <div class="mini-stat">
        <div class="mini-stat-value" id="db-total-songs">-</div>
        <div class="mini-stat-label">Unique Songs</div>
      </div>
      <div class="mini-stat">
        <div class="mini-stat-value" id="db-total-shows">-</div>
        <div class="mini-stat-label">Total Shows</div>
      </div>
    </div>
    
    <div class="search-container">
      <input type="text" id="db-song-search" placeholder="Search songs..." onkeyup="filterDbSongs()">
    </div>
    
    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortDbSongs('name')" style="cursor:pointer;">Song <span id="db-songs-sort-name">▲</span></th>
            <th onclick="sortDbSongs('played')" style="cursor:pointer;">Played <span id="db-songs-sort-played"></span></th>
            <th onclick="sortDbSongs('first')" style="cursor:pointer;">First <span id="db-songs-sort-first"></span></th>
            <th onclick="sortDbSongs('last')" style="cursor:pointer;">Last <span id="db-songs-sort-last"></span></th>
            <th onclick="sortDbSongs('gap')" style="cursor:pointer;">Gap <span id="db-songs-sort-gap"></span></th>
          </tr>
        </thead>
        <tbody id="db-songs-tbody"></tbody>
      </table>
    </div>
  </div>

  <div id="db-pairings" class="tab-pane">
    <div class="input-group">
      <input type="text" id="db-pair-song1" placeholder="First song...">
      <span style="font-size:1.5rem;">→</span>
      <input type="text" id="db-pair-song2" placeholder="Second song...">
      <button class="btn-search" onclick="searchDbPairing()">Search</button>
    </div>
    <div id="db-pairing-results"></div>
  </div>

  <div id="db-locations" class="tab-pane">
    <div class="search-container">
      <input type="text" id="db-location-search" placeholder="Search cities, states, venues..." onkeyup="filterDbLocations()">
    </div>
    
    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortDbLocations('location')" style="cursor:pointer;">Location <span id="db-locations-sort-location">▲</span></th>
            <th onclick="sortDbLocations('venue')" style="cursor:pointer;">Venue <span id="db-locations-sort-venue"></span></th>
            <th onclick="sortDbLocations('shows')" style="cursor:pointer;">Shows <span id="db-locations-sort-shows"></span></th>
            <th onclick="sortDbLocations('first')" style="cursor:pointer;">First <span id="db-locations-sort-first"></span></th>
            <th onclick="sortDbLocations('last')" style="cursor:pointer;">Last <span id="db-locations-sort-last"></span></th>
          </tr>
        </thead>
        <tbody id="db-locations-tbody"></tbody>
      </table>
    </div>
  </div>

  <div id="db-gaps" class="tab-pane">
    <div style="background:var(--card-bg);padding:2rem;border-radius:8px;border:1px solid var(--border-color);">
      <h3 style="margin-bottom:1rem;">Calculate Gaps</h3>
      
      <label style="display:block;margin-bottom:0.5rem;font-weight:600;">Search for song, city, state, or venue:</label>
      <input type="text" id="db-gap-input" placeholder="e.g., Minds Unchained, Chicago, IA, Red Rocks" style="width:100%;padding:0.75rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);">
      
      <button class="btn-search" style="margin-top:1rem;width:100%;" onclick="calculateDbGap()">Calculate</button>
      
      <div id="db-gap-result" style="display:none;" class="result-box"></div>
    </div>
  </div>

  <div id="db-song-detail" class="tab-pane">
    <div style="margin-bottom:1.5rem;">
      <h3 id="song-detail-title" style="color:var(--yellow);font-size:1.8rem;margin-bottom:0.5rem;"></h3>
      <div style="display:flex;gap:2rem;flex-wrap:wrap;color:var(--muted-color);align-items:center;">
        <div>Total Performances: <strong id="song-detail-count" style="color:var(--text-color);">-</strong></div>
        <div>First Played: <strong id="song-detail-first" style="color:var(--text-color);">-</strong></div>
        <div>Last Played: <strong id="song-detail-last" style="color:var(--text-color);">-</strong></div>
        <div>Current Gap: <strong id="song-detail-gap" style="color:var(--text-color);">-</strong> shows</div>
        <input type="text" id="song-detail-new-search" placeholder="Search for another song..." style="margin-left:auto;padding:0.5rem 1rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);width:200px;" onkeyup="if(event.key==='Enter') searchNewSongFromDetail()">
      </div>
    </div>

    <div class="search-container">
      <input type="text" id="song-detail-search" placeholder="Filter dates, venues..." onkeyup="filterSongDetail()" style="flex:1;">
    </div>

    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortSongDetail('date')">Date <span id="song-detail-date-sort">▲</span></th>
            <th onclick="sortSongDetail('venue')">Venue <span id="song-detail-venue-sort"></span></th>
            <th onclick="sortSongDetail('gap')">Gap <span id="song-detail-gap-sort"></span></th>
            <th onclick="sortSongDetail('set')">Set <span id="song-detail-set-sort"></span></th>
            <th onclick="sortSongDetail('songBefore')">Song Before</th>
            <th onclick="sortSongDetail('songAfter')">Song After</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody id="song-detail-tbody"></tbody>
      </table>
    </div>
  </div>
</div>
</div>

</main>
<script>
// JAM CHART CODE
let allJams = [];
let currentSort = {column:'date',direction:'desc'};
const tableBody = document.getElementById('jam-table-body');

// Add normalizeSongName function here, before it's used in processShowsDatabase
function normalizeSongName(s) {
  if (!s) return "";
  s = s.trim();

  // Normalize Unicode punctuation → ASCII
  s = s
    .normalize("NFKD")                    // canonical decomposition
    .replace(/[‘’‚‛]/g, "'")              // single quotes → '
    .replace(/[“”„‟]/g, '"')              // double quotes → "
    .replace(/[‐-‒–—―]/g, "-")            // dashes → -
    .replace(/\s+/g, " ");                // collapse spaces

  // Handle special multi-part titles
  if (/smooth.*relax.*down/i.test(s)) return "smooth relax down";
  if (/motel(\s*6)?/i.test(s)) return "motel 6";
  if (/april.*1992.*miami/i.test(s)) return "april 29 1992 miami";

  // Clean general junk and lowercase
  s = s
    .replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, "")
    .replace(/\s*\(\s*[\d:\-]+\s*\)\s*/g, "")
    .replace(/[|]+/g, " ")
    .replace(/[^\w\s,()'-]/g, "")
    .replace(/'/g, "")  // REMOVE APOSTROPHES for consistent matching
    .replace(/\s+/g, " ")
    .toLowerCase()
    .trim();

  return s;
}

function formatDateForDisplay(dateStr) {
  if (!dateStr) return '';
  try {
    let month, day, year;
    
    if (dateStr.includes('-') && dateStr.split('-')[0].length === 4) {
      [year, month, day] = dateStr.split('-').map(Number);
    } 
    else if (dateStr.includes('/')) {
      [month, day, year] = dateStr.split('/').map(Number);
    }
    else {
      return dateStr;
    }
    
    const monthStr = month.toString().padStart(2, '0');
    const dayStr = day.toString().padStart(2, '0');
    return `${monthStr}-${dayStr}-${year}`;
  } catch {
    return dateStr;
  }
}

function loadJams(){
  console.log('Loading jams.json...');
  fetch('jams.json')
  .then(r=>{
    console.log('Jams response:', r.status);
    return r.json();
  })
  .then(data=>{
    console.log('Jams loaded:', data.length, 'entries');
    
    // Process jams to add setlist order information
    const processedJams = [];
    
    data.forEach(entry => {
      entry.date = entry.date||'';
      entry.song = entry.song||'';
      entry.timing = entry.timing||'';
      entry.venue = entry.venue||'';
      entry.notes = entry.notes||'';
      entry.highlighted = !!entry.highlighted;
      
      // Try to find this jam in the setlist to get its position
      let setOrder = 99; // Default high value for sorting
      let positionInSet = 999;
      let foundSetName = '';
      
      // Convert date to match database format if needed
      const dbDate = entry.date.includes('-') && entry.date.split('-')[0].length === 4 
        ? entry.date 
        : (() => {
            // Handle MM-DD-YYYY format
            const [month, day, year] = entry.date.split('-');
            return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
          })();
      
      if (dbShows[dbDate]) {
        const show = dbShows[dbDate];
        const sets = show.sets || {};
        
        console.log(`🔍 Checking date: ${dbDate}`);
        console.log('Available sets:', Object.keys(sets));
        
        // Create an array of set entries and sort them by set order
        const setEntries = Object.entries(sets);
        
        // Sort sets by set name to ensure correct order
        setEntries.sort((a, b) => {
          const getSetNumber = (setName) => {
            setName = setName.toLowerCase();
            if (setName.includes('set1') || setName === '1' || setName === 'Set 1') return 1;
            if (setName.includes('set2') || setName === '2' || setName === 'Set 2') return 2;
            if (setName.includes('set3') || setName === '3' || setName === 'Set 3') return 3;
            if (setName.includes('encore')) return 4;
            if (setName.includes('set')) {
              // Extract number from "setX"
              const match = setName.match(/set\s*(\d+)/i);
              return match ? parseInt(match[1]) : 99;
            }
            return 99;
          };
          
          return getSetNumber(a[0]) - getSetNumber(b[0]);
        });
        
        console.log('Sorted sets:', setEntries.map(([name]) => name));
        
        // Now search through sets in correct order
        let found = false;
        for (const [setName, setContent] of setEntries) {
          console.log(`📋 Set ${setName}:`, setContent);
          const songs = parseDbSetlist(setContent);
          console.log(`🎵 Parsed songs in ${setName}:`, songs);
          
          const jamSongNorm = normalizeSongName(entry.song);
          console.log(`🎯 Looking for: "${entry.song}" (normalized: "${jamSongNorm}")`);
          
          for (let songIndex = 0; songIndex < songs.length; songIndex++) {
            const setlistSong = songs[songIndex];
            const setlistSongNorm = normalizeSongName(setlistSong);
            
            console.log(`   Comparing with: "${setlistSong}" (normalized: "${setlistSongNorm}")`);
            
            // Exact match
            if (setlistSongNorm === jamSongNorm) {
              found = true;
              foundSetName = setName;
              
              // Standardize set order
              if (setName.toLowerCase().includes('set1') || setName === '1' || setName === 'Set 1') setOrder = 1;
              else if (setName.toLowerCase().includes('set2') || setName === '2' || setName === 'Set 2') setOrder = 2;
              else if (setName.toLowerCase().includes('set3') || setName === '3' || setName === 'Set 3') setOrder = 3;
              else if (setName.toLowerCase().includes('encore')) setOrder = 4;
              else if (setName.toLowerCase().includes('set')) {
                // Extract number from "setX"
                const match = setName.toLowerCase().match(/set\s*(\d+)/);
                setOrder = match ? parseInt(match[1]) : 99;
              }
              
              positionInSet = songIndex;
              console.log(`✅ FOUND: "${entry.song}" in set ${setName} at position ${positionInSet} (order: ${setOrder})`);
              break;
            }
          }
          if (found) break; // Found it, stop searching
        }
        
        if (!found) {
          console.log(`❌ NOT FOUND: "${entry.song}" in any set for ${dbDate}`);
          // Let's try a more aggressive search
          console.log('🔄 Trying aggressive search...');
          for (const [setName, setContent] of setEntries) {
            const songs = parseDbSetlist(setContent);
            for (let songIndex = 0; songIndex < songs.length; songIndex++) {
              const setlistSong = songs[songIndex];
              const setlistSongNorm = normalizeSongName(setlistSong);
              const jamSongNorm = normalizeSongName(entry.song);
              
              // Check if either string contains the other
              if (setlistSongNorm.includes(jamSongNorm) || jamSongNorm.includes(setlistSongNorm)) {
                console.log(`🔄 PARTIAL MATCH: "${entry.song}" ≈ "${setlistSong}"`);
                found = true;
                foundSetName = setName;
                
                // Standardize set order (same as above)
                if (setName.toLowerCase().includes('set1') || setName === '1' || setName === 'Set 1') setOrder = 1;
                else if (setName.toLowerCase().includes('set2') || setName === '2' || setName === 'Set 2') setOrder = 2;
                else if (setName.toLowerCase().includes('set3') || setName === '3' || setName === 'Set 3') setOrder = 3;
                else if (setName.toLowerCase().includes('encore')) setOrder = 4;
                else if (setName.toLowerCase().includes('set')) {
                  const match = setName.toLowerCase().match(/set\s*(\d+)/);
                  setOrder = match ? parseInt(match[1]) : 99;
                }
                
                positionInSet = songIndex;
                console.log(`✅ AGGRESSIVE FOUND: "${entry.song}" in set ${setName} at position ${positionInSet}`);
                break;
              }
            }
            if (found) break;
          }
        }
      } else {
        console.log(`❌ NO SHOW DATA: No show data for date ${dbDate}`);
      }
      
      // Add setlist order info to the entry
      entry.setOrder = setOrder;
      entry.positionInSet = positionInSet;
      entry.dbDate = dbDate; // Store the database date for debugging
      
      const tr = document.createElement('tr');
      if(entry.highlighted) tr.classList.add('highlighted-row');
      const songSpan = document.createElement('span');
      songSpan.textContent = entry.song;
      songSpan.className = 'jam-entry' + (entry.highlighted?' highlighted':'');
      songSpan.classList.add('clickable-filter');
	// Look up location from shows database
let locationText = entry.venue; // fallback to venue name
try {
  const dbDate = entry.dbDate || (entry.date.includes('-') && entry.date.split('-')[0].length === 4 
    ? entry.date 
    : (() => {
        const [month, day, year] = entry.date.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      })());
  
  if (dbShows[dbDate]) {
    const show = dbShows[dbDate];
    locationText = `${show.city || 'Unknown'}, ${show.state || ''}`.trim();
    if (locationText.endsWith(',')) locationText = locationText.slice(0, -1);
  }
} catch (e) {
  console.log('Error getting location for', entry.date, e);
}

tr.innerHTML = `
  <td><span class="date-link" data-date="${entry.date}" style="cursor: pointer; color: var(--text-color);">${formatDateForDisplay(entry.date)}</span></td>
  <td></td>
  <td>${entry.timing}</td>
  <td><span class="clickable-filter">${locationText}</span></td>
  <td>${entry.notes}</td>
`;
      tr.children[1].appendChild(songSpan);
      entry.element = tr;
      processedJams.push(entry);
    });
    
    allJams = processedJams;
    
    // HARDCODE 2025-01-17 order
    const jan17Order = [
      "Neutrino", "Peaches", "Broken Wing", "Fake the Fate", "Levilan Shores",
      "Ain't That Wrong", "Pursuit of Trance", "Down Under", "Can't Find My Vape", "Galisteo Way", 
      "Frog Gossip"
    ];

    allJams.forEach(jam => {
      if (jam.date === '01-17-2025' || jam.dbDate === '2025-01-17') {
        const orderIndex = jan17Order.indexOf(jam.song);
        jam.hardcodedOrder = orderIndex >= 0 ? orderIndex : 999;
        console.log(`🔧 Hardcoded order for ${jam.song}: ${jam.hardcodedOrder}`);
      } else {
        jam.hardcodedOrder = 999; // Default high value for other shows
      }
    });
    
    // Debug: Show the order for 2025-01-17
    const jan17Jams = allJams.filter(j => j.dbDate === '2025-01-17');
    console.log('🎪 2025-01-17 Jams with set order BEFORE sorting:');
    jan17Jams.forEach(jam => {
      console.log(`   "${jam.song}" - Set: ${jam.setOrder}, Position: ${jam.positionInSet}, Hardcoded: ${jam.hardcodedOrder}`);
    });
    
    sortTable('date');
  })
  .catch(err=>{
    console.error("Failed to load jams.json:",err);
    tableBody.innerHTML='<tr><td colspan="5" style="text-align:center;color:var(--muted-color);padding:2rem;">Failed to load jams.json</td></tr>';
  });
}

function renderFilteredJams(){
  const searchTerm = document.getElementById('search-input').value.toLowerCase();
  const filterVal = document.getElementById('filter-select').value;

  const filtered = allJams.filter(j=>{
    if(filterVal==='highlighted' && !j.highlighted) return false;
    if(!searchTerm) return true;
    // Look up location for search
let locationText = j.venue; // fallback
try {
  const dbDate = j.dbDate || (j.date.includes('-') && j.date.split('-')[0].length === 4 
    ? j.date 
    : (() => {
        const [month, day, year] = j.date.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      })());
  
  if (dbShows[dbDate]) {
    const show = dbShows[dbDate];
    locationText = `${show.city || 'Unknown'}, ${show.state || ''}`.trim();
    if (locationText.endsWith(',')) locationText = locationText.slice(0, -1);
  }
} catch (e) {
  console.log('Error getting location for search:', j.date, e);
}

return j.song.toLowerCase().includes(searchTerm) ||
       locationText.toLowerCase().includes(searchTerm) ||
       j.date.includes(searchTerm) ||
       j.notes.toLowerCase().includes(searchTerm);
  });

  const frag = document.createDocumentFragment();
  filtered.forEach(j=>frag.appendChild(j.element));
  tableBody.innerHTML='';
  tableBody.appendChild(frag);

  if(filtered.length===0)
    tableBody.innerHTML='<tr><td colspan="5" style="text-align:center;color:var(--muted-color);padding:2rem;">No jams found matching your criteria.</td></tr>';
}

function sortTable(column){
  if(!allJams.length) return;
  if(currentSort.column===column) currentSort.direction = currentSort.direction==='asc'?'desc':'asc';
  else {currentSort.column=column; currentSort.direction='asc';}

  console.log(`🔄 Sorting by ${column} ${currentSort.direction}`);
  
  allJams.sort((a,b)=>{
    // HARDCODED ORDER for 2025-01-17 - FORCE this order regardless of other sorting
    if ((a.date === '01-17-2025' || a.dbDate === '2025-01-17') && 
        (b.date === '01-17-2025' || b.dbDate === '2025-01-17')) {
      const result = a.hardcodedOrder - b.hardcodedOrder;
      console.log(`🔧 Hardcoded sort: "${a.song}" (${a.hardcodedOrder}) vs "${b.song}" (${b.hardcodedOrder}) = ${result}`);
      return result;
    }
    
    let va=a[column], vb=b[column];
    
    if(column==='date'){
      const parseDate = (dateStr) => {
        try {
          if (dateStr.includes('-')) {
            return new Date(dateStr).getTime();
          }
          const [m,d,y] = dateStr.split('/').map(Number);
          return new Date(y,m-1,d).getTime();
        } catch {
          return 0;
        }
      };
      va = parseDate(va);
      vb = parseDate(vb);
      
      // If dates are equal, sort by set order and position in set
      if (va === vb) {
        if (a.setOrder !== b.setOrder) {
          console.log(`   Same date, different set order: "${a.song}" (set ${a.setOrder}) vs "${b.song}" (set ${b.setOrder})`);
          return a.setOrder - b.setOrder;
        }
        if (a.positionInSet !== b.positionInSet) {
          console.log(`   Same date and set, different position: "${a.song}" (pos ${a.positionInSet}) vs "${b.song}" (pos ${b.positionInSet})`);
          return a.positionInSet - b.positionInSet;
        }
        console.log(`   Same date, set, and position: "${a.song}" vs "${b.song}"`);
        return 0;
      }
    } else if(column==='timing'){
      const parseTime = (timeStr) => {
        if (!timeStr || typeof timeStr !== 'string') return 0;
        const parts = timeStr.split(':');
        const minutes = parseInt(parts[0]) || 0;
        const seconds = parseInt(parts[1]) || 0;
        return minutes * 60 + seconds;
      };
      va = parseTime(va);
      vb = parseTime(vb);
    } else {
      va = va.toString().toLowerCase(); 
      vb = vb.toString().toLowerCase();
    }
    
    const result = currentSort.direction==='asc'? (va<vb?-1:va>vb?1:0) : (va<vb?1:va>vb?-1:0);
    
    if (column === 'date' && a.date === '01-17-2025' && b.date === '01-17-2025') {
      console.log(`   Comparing "${a.song}" vs "${b.song}": ${result}`);
    }
    
    return result;
  });

  document.querySelectorAll('[id$="-sort"]').forEach(ind=>ind.textContent='');
  const curr=document.getElementById(currentSort.column+'-sort');
  if(curr) curr.textContent=currentSort.direction==='asc'?'▲':'▼';
  
  console.log('🎪 Final order for 2025-01-17:');
  allJams.filter(j => j.date === '01-17-2025').forEach((jam, index) => {
    console.log(`   ${index + 1}. "${jam.song}" - Hardcoded: ${jam.hardcodedOrder}`);
  });
  
  renderFilteredJams();
}

// Helper function to clean markdown
function cleanMarkdown(text) {
  if (!text) return '';
  
  return text
    .replace(/\*\*/g, '')  // Remove bold markers
    .replace(/\[\[|\]\]/g, '');  // Remove bracket markers
}

// SETLIST PAGE FUNCTION
function showSetlistForDate(date) {
  // Convert date format if needed (MM-DD-YYYY to YYYY-MM-DD)
  const dbDate = date.includes('-') && date.split('-')[0].length === 4 
    ? date 
    : (() => {
        const [month, day, year] = date.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      })();
  
  const show = dbShows[dbDate];
  if (!show) {
    alert(`No setlist data found for ${date}`);
    return;
  }
  
  // Get jam data for this date to check which songs are highlighted
  const jamEntries = allJams.filter(jam => 
    jam.date === date || jam.dbDate === dbDate
  );
  
  console.log(`🎵 Jam entries for ${dbDate}:`, jamEntries);
  
  // Find previous and next shows
  const allDates = Object.keys(dbShows).filter(d => d.match(/^\d{4}-\d{2}-\d{2}/)).sort();
  const currentIndex = allDates.indexOf(dbDate);
  const prevDate = currentIndex > 0 ? allDates[currentIndex - 1] : null;
  const nextDate = currentIndex < allDates.length - 1 ? allDates[currentIndex + 1] : null;
  
  // Format date for display (Month Date, Year)
  const [year, month, day] = dbDate.split('-').map(Number);
  const displayDate = new Date(year, month - 1, day).toLocaleDateString('en-US', {
    month: 'long',
    day: 'numeric',
    year: 'numeric'
  });
  
  // Hide other pages, show setlist page
  document.getElementById('page-jams').style.display = 'none';
  document.getElementById('page-stats').style.display = 'none';
  
  let setlistPage = document.getElementById('page-setlist');
  if (!setlistPage) {
    setlistPage = document.createElement('div');
    setlistPage.id = 'page-setlist';
    setlistPage.className = 'page-content';
    document.querySelector('main.container').appendChild(setlistPage);
  }
  
  setlistPage.style.display = 'block';
  
  // Update navigation tabs
  document.querySelectorAll('.page-tab').forEach(btn => btn.classList.remove('active'));
  
  // Clean rating value
  const cleanRating = show.rating ? cleanMarkdown(show.rating) : '';
  
  // Function to convert markdown to HTML with paragraph handling
  function markdownToHtml(text) {
    if (!text) return '';
    
    // Split by double newlines to handle paragraphs
    const paragraphs = text.split(/\n\n+/);
    
    const formattedParagraphs = paragraphs.map(paragraph => {
      // Convert **bold** to <strong>
      paragraph = paragraph.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      
      // Convert *italic* to <em>
      paragraph = paragraph.replace(/\*(.*?)\*/g, '<em>$1</em>');
      
      // Convert single newlines to <br> tags within paragraphs
      paragraph = paragraph.replace(/\n/g, '<br>');
      
      return paragraph;
    });
    
    // Only italicize the first paragraph (factual information)
    // Keep all other paragraphs (your review) in normal font
    return formattedParagraphs.map((paragraph, index) => {
      if (index === 0) {
        return `<div style="font-style: italic; margin-bottom: 1rem;">${paragraph}</div>`;
      } else {
        return `<div style="margin-bottom: 1rem;">${paragraph}</div>`;
      }
    }).join('');
  }

  // Improved function to make ALL songs clickable with better matching
  // Improved function to make ALL songs clickable with better matching
// SIMPLE AND RELIABLE APPROACH: Build setlist from scratch
// FIXED makeAllSongsClickable function to handle duplicate songs with different timings
// IMPROVED makeAllSongsClickable with exact timing matching
function makeAllSongsClickable(setContent, jamEntries) {
  if (!setContent) return '';
  
  const cleanedContent = cleanMarkdown(setContent);
  const allSongs = parseDbSetlist(setContent);
  
  if (allSongs.length === 0) return cleanedContent;
  
  let result = cleanedContent;
  
  // Process each song individually, finding ALL occurrences
  allSongs.forEach(song => {
    const timingMatch = song.match(/\((\d+)\)$/);
    const timing = timingMatch ? `(${timingMatch[1]})` : '';
    const timingNumber = timingMatch ? parseInt(timingMatch[1]) : null;
    let cleanSong = song.replace(/\s*\(\d+\)\s*$/, '').trim();
    cleanSong = cleanSong.replace(/\s+/g, ' ').trim();
    
    const normalizedSong = normalizeSongName(cleanSong);
    const searchText = cleanSong + (timing ? ' ' + timing : '');
    
    // Find ALL jam entries that could match this song (by name)
    const possibleJamEntries = jamEntries.filter(jam => {
      const jamSongClean = jam.song.replace(/\s+/g, ' ').trim();
      const jamNorm = normalizeSongName(jamSongClean);
      return jamNorm === normalizedSong;
    });
    
    // Find and replace ALL occurrences of this song+timing
    let position = 0;
    while ((position = result.indexOf(searchText, position)) !== -1) {
      // For this specific occurrence, find the best matching jam entry
      let bestJamEntry = null;
      
      if (possibleJamEntries.length > 0) {
        if (possibleJamEntries.length === 1) {
          // Only one possible match, use it
          bestJamEntry = possibleJamEntries[0];
        } else if (timingNumber) {
          // Multiple matches - find EXACT timing match first
          bestJamEntry = possibleJamEntries.find(jam => {
            const jamTimingMatch = jam.timing.match(/(\d+):(\d+)/);
            if (!jamTimingMatch) return false;
            
            const jamMinutes = parseInt(jamTimingMatch[1]);
            // Allow 1-minute tolerance for rounding differences
            return Math.abs(jamMinutes - timingNumber) <= 1;
          });
          
          // If no exact match, don't use any jam entry for this occurrence
          // This prevents wrong jam entries from being assigned
          if (!bestJamEntry) {
            console.log(`No exact timing match for "${cleanSong}" (${timingNumber} min) - skipping jam highlighting`);
          }
        } else {
          // No timing info, don't assign any jam entry to avoid wrong matches
          console.log(`No timing info for "${cleanSong}" - skipping jam highlighting`);
        }
      }
      
      // Create replacement HTML
      let replacement;
      if (bestJamEntry) {
        replacement = `<span class="clickable-song jam-song" data-song="${cleanSong.replace(/"/g, '&quot;')}" data-timing="${timingNumber || ''}" data-jam="true">${cleanSong}</span> ${timing}`;
      } else {
        replacement = `<span class="clickable-song" data-song="${cleanSong.replace(/"/g, '&quot;')}" data-timing="${timingNumber || ''}" data-jam="false">${cleanSong}</span> ${timing}`;
      }
      
      // Replace at this specific position
      result = result.substring(0, position) + 
               replacement + 
               result.substring(position + searchText.length);
      
      // Move position forward to continue searching
      position += replacement.length;
    }
  });
  
  return result;
}

  // Build setlist content with better spacing
  let content = `
    <div style="margin-bottom: 1.5rem;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <div style="display: flex; gap: 0.5rem;">
          <button onclick="closeSetlistPage()" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); cursor: pointer;">← Back</button>
          ${prevDate ? `<button onclick="showSetlistForDate('${prevDate}')" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); cursor: pointer;">← Previous</button>` : '<button disabled style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--muted-color); cursor: not-allowed;">← Previous</button>'}
        </div>
        
        <div style="display: flex; gap: 0.5rem;">
          <button onclick="showRandomSetlist()" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); cursor: pointer;">🎲 Random</button>
        </div>
        
        <div style="display: flex; gap: 0.5rem;">
          ${nextDate ? `<button onclick="showSetlistForDate('${nextDate}')" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); cursor: pointer;">Next →</button>` : '<button disabled style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--muted-color); cursor: not-allowed;">Next →</button>'}
        </div>
      </div>
    </div>
    
    <div style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; max-width: 700px; margin: 0 auto;">
      <div style="margin-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem;">
        <h1 style="color: var(--yellow); font-size: 1.8rem; margin-bottom: 0.5rem; text-align: left;">${displayDate}</h1>
        <div style="font-size: 1.1rem; margin-bottom: 0.3rem; text-align: left;">${show.venue}</div>
        <div style="color: var(--muted-color); font-size: 0.95rem; text-align: left; margin-bottom: 0.3rem;">${show.city}, ${show.state}</div>
        ${show.tour || show.show_number ? `<div style="color: var(--muted-color); font-size: 0.9rem; text-align: left;">${show.tour ? `${show.tour}` : ''}${show.tour && show.show_number ? ' • ' : ''}${show.show_number ? `Show #${show.show_number}` : ''}</div>` : ''}
        ${cleanRating && cleanRating !== 'tags:' ? `<div style="font-size: 0.95rem; margin-top: 0.5rem;">★ ${cleanRating}</div>` : ''}
      </div>
      
      <div style="margin-bottom: 1.5rem;">
        <div style="line-height: 1.6; color: var(--text-color); font-size: 0.95rem;">
  `;
  
  // Process each set
  const setOrder = ['Set 1', 'Set 2', 'Set 3', 'Encore'];
  const specialSections = ["Chuck's Dream"];
  
  let displayedChucksDream = false;
  
  setOrder.forEach(setName => {
    if (show.sets[setName]) {
      console.log(`🎪 Processing ${setName}:`, show.sets[setName]);
      const processedContent = makeAllSongsClickable(show.sets[setName], jamEntries);
      content += `<div style="margin-bottom: 0.75rem;"><strong>${setName}:</strong> ${processedContent}</div>`;
      
      // Display Chuck's Dream after Set 1
      if (setName === 'Set 1' && show.sets["Chuck's Dream"] && !displayedChucksDream) {
        const chucksContent = makeAllSongsClickable(show.sets["Chuck's Dream"], jamEntries);
        content += `<div style="margin-bottom: 0.75rem; font-style: italic;"><strong>Chuck's Dream:</strong> ${chucksContent}</div>`;
        displayedChucksDream = true;
      }
    }
  });
  
  // Check for any other set names
  Object.keys(show.sets).forEach(setName => {
    if (!setOrder.includes(setName) && setName !== "Chuck's Dream") {
      const processedContent = makeAllSongsClickable(show.sets[setName], jamEntries);
      const isSpecial = specialSections.includes(setName);
      const style = isSpecial ? 'font-style: italic;' : '';
      content += `<div style="margin-bottom: 0.75rem; ${style}"><strong>${setName}:</strong> ${processedContent}</div>`;
    }
  });
  
  content += `</div></div>`;
  
  // Add notes section if available
  if (show.notes && show.notes.length > 0) {
    // Combine all notes and convert markdown to HTML
    const combinedNotes = show.notes.join('\n\n');
    const formattedNotes = markdownToHtml(combinedNotes);
    
    content += `
      <div style="margin-top: 2rem;">
        <div style="color: var(--text-color); line-height: 1.8;">
          ${formattedNotes}
        </div>
      </div>
    `;
  }
  
  content += `</div>`;
  
  setlistPage.innerHTML = content;
  
  // Add CSS for the tooltip
  const tooltipCSS = `
  <style>
    .jam-song-tooltip {
      position: absolute;
      background: var(--card-bg);
      border: 1px solid var(--yellow);
      border-radius: 6px;
      padding: 0.75rem 1rem;
      color: var(--text-color);
      font-size: 0.85rem;
      line-height: 1.4;
      z-index: 1000;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    
    .jam-song-tooltip.show {
      opacity: 1;
    }
    
    .jam-song-tooltip-timing {
      color: var(--yellow);
      font-weight: bold;
      margin-bottom: 0.25rem;
    }
    
    .jam-song-tooltip-notes {
      color: var(--text-color);
    }
    
    /* Style the song spans directly */
    .jam-song {
      color: var(--yellow) !important;
      cursor: pointer;
    }
    
    .jam-song.highlighted {
      font-weight: bold !important;
    }
    
    .clickable-song {
      cursor: pointer;
    }
    
    .clickable-song:hover {
      background-color: rgba(255, 235, 59, 0.15);
      border-radius: 4px;
      padding: 2px 4px;
      margin: -2px -4px;
    }
  </style>
`;
  
  // Add tooltip CSS to the page
  if (!document.getElementById('setlist-tooltip-css')) {
    const styleElement = document.createElement('div');
    styleElement.id = 'setlist-tooltip-css';
    styleElement.innerHTML = tooltipCSS;
    document.head.appendChild(styleElement);
  }
  
  // Add click and hover handlers after the content is rendered
  // In the event handler setup section:
// In the event handler setup:
// In the event handler setup, fix the click handler:
setTimeout(() => {
  let currentTooltip = null;
  
  console.log('Setting up clickable songs...');
  console.log('Jam entries available:', jamEntries.length);
  
  // Set up ALL clickable songs first
  document.querySelectorAll('.clickable-song').forEach((songElement, index) => {
    const songName = songElement.getAttribute('data-song');
    const isJamCharted = songElement.getAttribute('data-jam') === 'true';
    const elementTiming = songElement.getAttribute('data-timing');
    
    console.log(`Setting up song ${index + 1}: "${songName}" (jam charted: ${isJamCharted}, timing: ${elementTiming})`);
    
    // Apply basic styling
    if (isJamCharted) {
      songElement.style.color = 'var(--yellow)';
      songElement.style.cursor = 'pointer';
    } else {
      songElement.style.color = 'var(--text-color)';
      songElement.style.cursor = 'pointer';
    }
    
    // Click handler for ALL songs - FIXED for non-jam-charted songs
    songElement.addEventListener('click', function(e) {
      e.stopPropagation();
      console.log(`Clicked on: "${songName}" (jam charted: ${isJamCharted})`);
      
      if (isJamCharted) {
        // For jam charted songs, search in jam chart
        switchPageByName('jams');
        document.getElementById('search-input').value = songName;
        renderFilteredJams();
      } else {
        // For regular songs, show song history - FIXED: ensure this works
        console.log(`Showing song detail for: "${songName}"`);
        const normalizedName = normalizeSongName(songName);
        console.log(`Normalized name: "${normalizedName}"`);
        
        // Check if song exists in database
        if (dbSongs[normalizedName]) {
          showSongDetail(normalizedName);
        } else {
          // If not found, search for similar songs
          const similarSong = Object.keys(dbSongs).find(songKey => 
            normalizeSongName(songKey).includes(normalizedName) || 
            normalizedName.includes(normalizeSongName(songKey))
          );
          
          if (similarSong) {
            showSongDetail(similarSong);
          } else {
            console.log(`Song "${songName}" not found in database`);
            // Fallback: switch to stats page and search for the song
            switchPageByName('stats');
            document.getElementById('db-song-search').value = songName;
            filterDbSongs();
          }
        }
      }
    });
  });
  
  // Set up hover tooltips for ALL jam-charted songs with exact timing matching
  const jamSongs = document.querySelectorAll('.jam-song');
  console.log(`Found ${jamSongs.length} jam-charted songs to set up tooltips for`);
  
  jamSongs.forEach((songElement, index) => {
    const songName = songElement.getAttribute('data-song');
    const elementTiming = songElement.getAttribute('data-timing');
    const elementTimingNumber = elementTiming ? parseInt(elementTiming) : null;
    
    console.log(`Setting up tooltip for jam song ${index + 1}: "${songName}" (timing: ${elementTiming})`);
    
    // Find ALL possible jam entries for this song
    const possibleJamEntries = jamEntries.filter(jam => {
      const jamSongClean = jam.song.replace(/\s+/g, ' ').trim();
      const jamNorm = normalizeSongName(jamSongClean);
      const currentNorm = normalizeSongName(songName);
      return jamNorm === currentNorm;
    });
    
    console.log(`Found ${possibleJamEntries.length} possible jam entries for "${songName}"`);
    
    // Find the best matching jam entry for this specific occurrence
    let bestJamEntry = null;
    
    if (possibleJamEntries.length > 0) {
      if (possibleJamEntries.length === 1) {
        bestJamEntry = possibleJamEntries[0];
        console.log(`Single jam entry found for "${songName}": ${bestJamEntry.timing}`);
      } else if (elementTimingNumber) {
        // Multiple matches - find EXACT timing match
        bestJamEntry = possibleJamEntries.find(jam => {
          const jamTimingMatch = jam.timing.match(/(\d+):(\d+)/);
          if (!jamTimingMatch) return false;
          
          const jamMinutes = parseInt(jamTimingMatch[1]);
          // Allow 1-minute tolerance for rounding differences
          const timingDiff = Math.abs(jamMinutes - elementTimingNumber);
          console.log(`Comparing "${songName}": jam ${jamMinutes}min vs element ${elementTimingNumber}min = diff ${timingDiff}`);
          return timingDiff <= 1;
        });
        
        if (bestJamEntry) {
          console.log(`Exact timing match found for "${songName}": ${bestJamEntry.timing}`);
        } else {
          console.log(`No exact timing match for "${songName}" (${elementTimingNumber} min) - available: ${possibleJamEntries.map(j => j.timing).join(', ')}`);
        }
      } else {
        console.log(`No timing info for "${songName}" - cannot choose between ${possibleJamEntries.length} jam entries`);
      }
    }
    
    if (bestJamEntry) {
      // Apply highlighted styling
      if (bestJamEntry.highlighted) {
        songElement.style.fontWeight = 'bold';
      }
      
      const timing = bestJamEntry.timing;
      const notes = bestJamEntry.notes ? bestJamEntry.notes.replace(/<[^>]*>/g, '').trim() : '';
      
      // Add hover events
      songElement.addEventListener('mouseover', function(e) {
        if (timing || notes) {
          if (currentTooltip) {
            currentTooltip.remove();
          }
          
          currentTooltip = document.createElement('div');
          currentTooltip.className = 'jam-song-tooltip';
          
          let tooltipContent = '';
          if (timing && notes) {
            tooltipContent = `
              <div class="jam-song-tooltip-timing">${timing}</div>
              <div class="jam-song-tooltip-notes">${notes}</div>
            `;
          } else if (timing) {
            tooltipContent = `<div class="jam-song-tooltip-timing">${timing}</div>`;
          } else if (notes) {
            tooltipContent = `<div class="jam-song-tooltip-notes">${notes}</div>`;
          }
          
          currentTooltip.innerHTML = tooltipContent;
          document.body.appendChild(currentTooltip);
          
          const rect = this.getBoundingClientRect();
          const tooltipHeight = currentTooltip.offsetHeight;
          const tooltipWidth = currentTooltip.offsetWidth;
          
          let top = rect.top - tooltipHeight - 8;
          let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
          
          if (top < 10) top = rect.bottom + 8;
          if (left < 10) left = 10;
          if (left + tooltipWidth > window.innerWidth - 10) {
            left = window.innerWidth - tooltipWidth - 10;
          }
          
          currentTooltip.style.top = top + 'px';
          currentTooltip.style.left = left + 'px';
          
          setTimeout(() => {
            if (currentTooltip) {
              currentTooltip.classList.add('show');
            }
          }, 50);
        }
      });
      
      songElement.addEventListener('mouseout', function() {
        if (currentTooltip) {
          currentTooltip.remove();
          currentTooltip = null;
        }
      });
    } else {
      console.log(`No suitable jam entry found for "${songName}" - removing jam highlighting`);
      // Remove jam highlighting since we couldn't find the right match
      songElement.classList.remove('jam-song');
      songElement.style.color = 'var(--text-color)';
      songElement.setAttribute('data-jam', 'false');
    }
  });
  
  console.log('Finished setting up all song interactions');
}, 0);
  
  window.scrollTo(0, 0);
}

function closeSetlistPage() {
  document.getElementById('page-setlist').style.display = 'none';
  switchPageByName('jams');
}

// FIXED CLICK HANDLERS - dates don't trigger search
tableBody.addEventListener('click', e => {
  let target = e.target;
  
  // Handle date clicks for setlist modal
	if (target.classList.contains('date-link')) {
  const date = target.getAttribute('data-date');
  showSetlistForDate(date);
  e.stopPropagation(); // Prevent triggering search
  return;
}
  
  // Handle regular clickable filters for search
  target = e.target.closest('.clickable-filter');
  if(!target) return;
  
  // Remove any selected-row highlights
  document.querySelectorAll('.selected-row').forEach(row => row.classList.remove('selected-row'));
  
  document.getElementById('search-input').value = target.textContent.trim();
  renderFilteredJams();
});

// DATABASE EXPLORER CODE
let dbShows = {};
let dbSongs = {};
let dbLocations = {};
let dbSongRows = [];
let dbLocationRows = [];
let dbDates = [];
let dbSortState = { 
  songs: {column:'name',direction:'asc'}, 
  locations: {column:'location',direction:'asc'}, 
  songDetail: {column:'date',direction:'asc'} 
};
let currentSongDetail = null;
let songDetailRows = [];

function switchPage(page) {
  document.querySelectorAll('.page-tab').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.page-content').forEach(pane => pane.style.display = 'none');
  
  event.target.classList.add('active');
  document.getElementById('page-' + page).style.display = 'block';
}

function parseDbSetlist(str) {
  if (!str || typeof str !== 'string') return [];

  // Step 1: Clean the string but preserve timing numbers
  str = str.trim();
  if (!str) return [];

  // Step 2: Protect known multi-part names
  str = str
    .replace(/Smooth,\s*Relax,\s*Down/gi, '|||SMOOTH_RELAX_DOWN|||')
    .replace(/\bMotel\s*(?:6)?\b/gi, '|||MOTEL_6|||')
    .replace(/April\s*29,\s*1992\s*\(Miami\)/gi, '|||APRIL_MIAMI|||');

  // Step 3: Clean markdown but preserve timing numbers
  str = cleanMarkdown(str);

  // Step 4: Use a different approach - split on arrows and commas
  // First, normalize all whitespace
  str = str.replace(/\s+/g, ' ');
  
  // Split on arrows and commas to get individual song entries
  const tempParts = str.split(/(->|>|,)/);
  
  // Process each part to extract songs
  const songs = [];
  let currentSong = '';
  
  tempParts.forEach(part => {
    part = part.trim();
    if (!part) return;
    
    if (part === '->' || part === '>' || part === ',') {
      // If we have a current song, add it to the list
      if (currentSong.trim()) {
        songs.push(currentSong.trim());
        currentSong = '';
      }
    } else {
      // This is a song (possibly with timing)
      if (currentSong) {
        currentSong += ' ' + part;
      } else {
        currentSong = part;
      }
      
      // Check if this part ends a song (has timing or is the last part)
      const hasTiming = /\(\d+\)$/.test(part);
      if (hasTiming) {
        songs.push(currentSong.trim());
        currentSong = '';
      }
    }
  });
  
  // Add the last song if there is one
  if (currentSong.trim()) {
    songs.push(currentSong.trim());
  }

  // Step 5: Filter and clean
  const filteredSongs = songs
    .filter(s => s && /[a-z]/i.test(s)) // ensure it contains letters
    .filter(s => !/^set\s*\d*$/i.test(s)) // skip "Set 1" etc.
    .filter(s => s.toLowerCase() !== 'unknown')
    .map(s => s.trim());

  // Step 6: Restore protected names
  return filteredSongs.map(s =>
    s
      .replace(/SMOOTH_RELAX_DOWN/gi, 'Smooth, Relax, Down')
      .replace(/MOTEL_6/gi, 'Motel 6')
      .replace(/APRIL_MIAMI/gi, 'April 29, 1992 (Miami)')
  );
}

function loadShowsDatabase() {
  console.log('Loading shows_database.json...');
  fetch('shows_database.json')
    .then(r => {
      console.log('Shows database response:', r.status);
      return r.json();
    })
    .then(data => {
      console.log('Shows database loaded:', Object.keys(data).length, 'shows');
      dbShows = data;
      processShowsDatabase();
      renderDbSongs();
      renderDbLocations();
      // Now that dbShows is loaded, load the jams
      loadJams();
    })
    .catch(err => {
      console.error('Failed to load shows_database.json:', err);
      document.getElementById('db-songs-tbody').innerHTML = 
        '<tr><td colspan="5" style="text-align:center;padding:2rem;color:var(--muted-color);">Failed to load shows_database.json</td></tr>';
    });
}

function processShowsDatabase() {
  const songs = {};
  const locations = {};
  dbDates = Object.keys(dbShows)
    .filter(d => d.match(/^\d{4}-\d{2}-\d{2}/))
    .sort();

  dbDates.forEach(date => {
    const show = dbShows[date];
    const venue = show.venue || "Unknown";
    const city = show.city || "Unknown";
    const state = show.state || "";
    const locationKey = `${city}, ${state}`.trim();

    if (!locations[locationKey]) {
      locations[locationKey] = {
        venue,
        shows: [],
        firstShow: date,
        lastShow: date,
      };
    }
    locations[locationKey].shows.push(date);
    locations[locationKey].lastShow = date;

    const sets = show.sets || {};
    Object.values(sets).forEach(setContent => {
      const songList = parseDbSetlist(setContent);
      songList.forEach(song => {
        let norm = normalizeSongName(song);
        let displayName = song.trim()
          .replace(/^[\s|]+/, "")
          .replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, "")
          .replace(/\s*\(\s*[\d:\-]+\s*\)\s*/g, "")
          .replace(/[,\s]+$/, "")
          .trim();

        // SPECIAL HANDLING: Merge all variations of "To Be Young..."
        if (norm.includes("to be young") || norm.includes("is to be high") || norm.includes("is to be sad")) {
          norm = "to be young is to be sad is to be high";
          displayName = "To Be Young (Is to Be Sad, Is to Be High)";
        }
        
        if (norm.includes("april 29 1992 miami")) displayName = "April 29, 1992 (Miami)";
        else if (norm.includes("smooth relax down")) displayName = "Smooth, Relax, Down";
        else if (norm.includes("motel 6")) displayName = "Motel 6";

        if (!songs[norm]) {
          songs[norm] = {
            name: displayName,
            performances: [],
            firstPlayed: date,
            lastPlayed: date,
          };
        }

        // Instead of just pushing the date, push an object with the date
// This allows us to count total performances, not just unique dates
songs[norm].performances.push({
  date: date,
  // We can add more info here if needed, like set position
});
        if (new Date(date) < new Date(songs[norm].firstPlayed))
          songs[norm].firstPlayed = date;
        if (new Date(date) > new Date(songs[norm].lastPlayed))
          songs[norm].lastPlayed = date;
      });
    });
  });

  // 💥 FINAL CROSS-MERGE: collapse any duplicates that slipped through
const merged = {};
Object.values(songs).forEach(song => {
  // Extra-strict normalization of merge key
  const key = normalizeSongName(song.name).replace(/[^\w\s]/g, "").trim();
  if (!key) return;

  if (!merged[key]) {
    merged[key] = {
      name: song.name,
      performances: [...song.performances],
      firstPlayed: song.firstPlayed,
      lastPlayed: song.lastPlayed,
    };
  } else {
    merged[key].performances.push(...song.performances);
    merged[key].performances = [...new Set(merged[key].performances)].sort(
      (a, b) => new Date(a) - new Date(b)
    );
    if (new Date(song.firstPlayed) < new Date(merged[key].firstPlayed))
      merged[key].firstPlayed = song.firstPlayed;
    if (new Date(song.lastPlayed) > new Date(merged[key].lastPlayed))
      merged[key].lastPlayed = song.lastPlayed;
  }
});


  dbSongs = merged;
  dbLocations = locations;

  document.getElementById("db-total-songs").textContent = Object.keys(merged).length;
  document.getElementById("db-total-shows").textContent = dbDates.length;
}

function renderDbSongs() {
  const tbody = document.getElementById('db-songs-tbody');
  tbody.innerHTML = '';
  dbSongRows = [];
  
  let sortedSongs = Object.entries(dbSongs);
  
  // Apply sorting
  const sort = dbSortState.songs;
  sortedSongs.sort((a, b) => {
    let va, vb;
    if (sort.column === 'name') {
      va = a[1].name.toLowerCase();
      vb = b[1].name.toLowerCase();
    } else if (sort.column === 'played') {
      va = a[1].performances.length;
      vb = b[1].performances.length;
    } else if (sort.column === 'first') {
      va = new Date(a[1].firstPlayed).getTime();
      vb = new Date(b[1].firstPlayed).getTime();
    } else if (sort.column === 'last') {
      va = new Date(a[1].lastPlayed).getTime();
      vb = new Date(b[1].lastPlayed).getTime();
    } else if (sort.column === 'gap') {
      const aLastIdx = dbDates.indexOf(a[1].lastPlayed);
      const bLastIdx = dbDates.indexOf(b[1].lastPlayed);
      va = dbDates.length - 1 - aLastIdx;
      vb = dbDates.length - 1 - bLastIdx;
    }
    
    return sort.direction === 'asc' ? (va < vb ? -1 : va > vb ? 1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });
  
  sortedSongs.forEach(([norm, data]) => {
    const lastIdx = dbDates.indexOf(data.lastPlayed);
    const currentGap = dbDates.length - 1 - lastIdx;
    
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter song-name-link" data-song-norm="${norm}">${data.name}</span></td>
      <td>${data.performances.length}</td>
      <td><span class="clickable-filter">${data.firstPlayed}</span></td>
      <td><span class="clickable-filter">${data.lastPlayed}</span></td>
      <td>${currentGap}</td>
    `;
    dbSongRows.push({ element: tr, data });
    tbody.appendChild(tr);
  });
}

function sortDbSongs(column) {
  if (dbSortState.songs.column === column) {
    dbSortState.songs.direction = dbSortState.songs.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.songs.column = column;
    dbSortState.songs.direction = 'asc';
  }
  
  document.querySelectorAll('#db-songs thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('db-songs-sort-' + column);
  if (indicator) indicator.textContent = dbSortState.songs.direction === 'asc' ? '▲' : '▼';
  
  renderDbSongs();
  filterDbSongs();
}

function renderDbLocations() {
  const tbody = document.getElementById('db-locations-tbody');
  tbody.innerHTML = '';
  dbLocationRows = [];
  
  let sortedLocations = Object.entries(dbLocations);
  
  // Apply sorting
  const sort = dbSortState.locations;
  sortedLocations.sort((a, b) => {
    let va, vb;
    if (sort.column === 'location') {
      va = a[0].toLowerCase();
      vb = b[0].toLowerCase();
    } else if (sort.column === 'venue') {
      va = a[1].venue.toLowerCase();
      vb = b[1].venue.toLowerCase();
    } else if (sort.column === 'shows') {
      va = a[1].shows.length;
      vb = b[1].shows.length;
    } else if (sort.column === 'first') {
      va = new Date(a[1].firstShow).getTime();
      vb = new Date(b[1].firstShow).getTime();
    } else if (sort.column === 'last') {
      va = new Date(a[1].lastShow).getTime();
      vb = new Date(b[1].lastShow).getTime();
    }
    
    return sort.direction === 'asc' ? (va < vb ? -1 : va > vb ? 1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });
  
  sortedLocations.forEach(([location, data]) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter">${location}</span></td>
      <td><span class="clickable-filter">${data.venue}</span></td>
      <td>${data.shows.length}</td>
      <td><span class="clickable-filter">${data.firstShow}</span></td>
      <td><span class="clickable-filter">${data.lastShow}</span></td>
    `;
    dbLocationRows.push({ element: tr, location, data });
    tbody.appendChild(tr);
  });
}

function sortDbLocations(column) {
  if (dbSortState.locations.column === column) {
    dbSortState.locations.direction = dbSortState.locations.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.locations.column = column;
    dbSortState.locations.direction = 'asc';
  }
  
  document.querySelectorAll('#db-locations thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('db-locations-sort-' + column);
  if (indicator) indicator.textContent = dbSortState.locations.direction === 'asc' ? '▲' : '▼';
  
  renderDbLocations();
  filterDbLocations();
}

function filterDbSongs() {
  const search = document.getElementById('db-song-search').value.toLowerCase();
  const tbody = document.getElementById('db-songs-tbody');
  tbody.innerHTML = '';
  
  dbSongRows
    .filter(row => !search || row.data.name.toLowerCase().includes(search))
    .forEach(row => tbody.appendChild(row.element));
}

function filterDbLocations() {
  const search = document.getElementById('db-location-search').value.toLowerCase();
  const tbody = document.getElementById('db-locations-tbody');
  tbody.innerHTML = '';
  
  dbLocationRows
    .filter(row => !search || 
      row.location.toLowerCase().includes(search) ||
      row.data.venue.toLowerCase().includes(search))
    .forEach(row => tbody.appendChild(row.element));
}

function searchDbPairing() {
  const song1 = document.getElementById('db-pair-song1').value.trim();
  const song2 = document.getElementById('db-pair-song2').value.trim();
  const resultsDiv = document.getElementById('db-pairing-results');
  
  if (!song1 || !song2) {
    resultsDiv.innerHTML = '<div class="result-box">Please enter both song names</div>';
    return;
  }
  
  const norm1 = normalizeSongName(song1);
  const norm2 = normalizeSongName(song2);
  const sequences = [];
  const coAppearances = [];
  
  dbDates.forEach(date => {
    const show = dbShows[date];
    const sets = show.sets || {};
    let foundSequence = false;
    let found1 = false, found2 = false;
    
    Object.values(sets).forEach(setContent => {
      const songs = parseDbSetlist(setContent);
      const normalized = songs.map(s => normalizeSongName(s));
      
      for (let i = 0; i < normalized.length - 1; i++) {
        if (normalized[i] === norm1 && normalized[i + 1] === norm2) {
          foundSequence = true;
          break;
        }
      }
      
      if (normalized.includes(norm1)) found1 = true;
      if (normalized.includes(norm2)) found2 = true;
    });
    
    if (foundSequence) {
      sequences.push({ date, venue: `${show.venue}, ${show.city}, ${show.state}` });
    } else if (found1 && found2) {
      coAppearances.push({ date, venue: `${show.venue}, ${show.city}, ${show.state}` });
    }
  });
  
  if (sequences.length > 0) {
    resultsDiv.innerHTML = `
      <div class="result-box">
        <strong>Found ${sequences.length} "${song1} → ${song2}" sequence(s):</strong><br><br>
        ${sequences.map(m => `${m.date} - ${m.venue}`).join('<br>')}
      </div>
    `;
  } else if (coAppearances.length > 0) {
    resultsDiv.innerHTML = `
      <div class="result-box">
        <strong>No direct sequences, but found ${coAppearances.length} show(s) with both songs:</strong><br><br>
        ${coAppearances.map(m => `${m.date} - ${m.venue}`).join('<br>')}
      </div>
    `;
  } else {
    resultsDiv.innerHTML = '<div class="result-box">No pairings or co-appearances found</div>';
  }
}

function calculateDbGap() {
  const input = document.getElementById('db-gap-input').value.trim();
  const resultDiv = document.getElementById('db-gap-result');
  
  if (!input) {
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = 'Please enter a song, city, state, or venue';
    return;
  }
  
  // Try matching as a song first
  const normInput = normalizeSongName(input);
  if (dbSongs[normInput]) {
    const song = dbSongs[normInput];
    
    // Get unique dates only
    const uniqueDates = [...new Set(song.performances)];
    
    if (uniqueDates.length < 2) {
      resultDiv.style.display = 'block';
      resultDiv.innerHTML = `"${song.name}" has only been played ${uniqueDates.length} time(s)`;
      return;
    }
    
    const recent = uniqueDates[uniqueDates.length - 1];
    const previous = uniqueDates[uniqueDates.length - 2];
    const recentShow = dbShows[recent];
    const prevShow = dbShows[previous];
    
    const showGap = dbDates.indexOf(recent) - dbDates.indexOf(previous) - 1;
    const dayGap = Math.floor((new Date(recent) - new Date(previous)) / (1000 * 60 * 60 * 24));
    
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = `<strong>GAP ANALYSIS: ${song.name}</strong>

Most Recent:  ${recent}
Venue:        ${recentShow.venue}, ${recentShow.city}, ${recentShow.state}

Previous:     ${previous}
Venue:        ${prevShow.venue}, ${prevShow.city}, ${prevShow.state}

<strong>GAP:</strong>
Shows:        ${showGap} shows between
Days:         ${dayGap} days
Total Played: ${uniqueDates.length} times`;
    return;
  }
  
  // Try matching as state, city, or venue
  let matchingShows = [];
  const upperInput = input.toUpperCase();
  const lowerInput = input.toLowerCase();
  
  // Check if it's a state code (2 letters)
  if (input.length === 2) {
    matchingShows = dbDates.filter(d => dbShows[d].state?.toUpperCase() === upperInput);
  }
  
  // If no state matches, try city
  if (matchingShows.length === 0) {
    matchingShows = dbDates.filter(d => 
      dbShows[d].city?.toLowerCase().includes(lowerInput)
    );
  }
  
  // If still no matches, try venue
  if (matchingShows.length === 0) {
    matchingShows = dbDates.filter(d => 
      dbShows[d].venue?.toLowerCase().includes(lowerInput)
    );
  }
  
  if (matchingShows.length < 2) {
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = `Only ${matchingShows.length} show(s) found for "${input}"`;
    return;
  }
  
  const recent = matchingShows[matchingShows.length - 1];
  const previous = matchingShows[matchingShows.length - 2];
  
  const recentShow = dbShows[recent];
  const prevShow = dbShows[previous];
  
  const showGap = dbDates.indexOf(recent) - dbDates.indexOf(previous) - 1;
  const dayGap = Math.floor((new Date(recent) - new Date(previous)) / (1000 * 60 * 60 * 24));
  
  resultDiv.style.display = 'block';
  resultDiv.innerHTML = `<strong>GAP ANALYSIS: ${input}</strong>

Most Recent:  ${recent}
Venue:        ${recentShow.venue}, ${recentShow.city}, ${recentShow.state}

Previous:     ${previous}
Venue:        ${prevShow.venue}, ${prevShow.city}, ${prevShow.state}

<strong>GAP:</strong>
Shows:        ${showGap} shows between
Days:         ${dayGap} days
Total Shows:  ${matchingShows.length} in ${input}`;
}

// Add click handlers for stats tables to navigate back to jam chart
document.addEventListener('click', e => {
  // Check for song name link in song history
  if (e.target.classList.contains('song-name-link')) {
    const norm = e.target.getAttribute('data-song-norm');
    showSongDetail(norm);
    return;
  }
  
  const target = e.target.closest('.clickable-filter');
  if (!target) return;
  
  // Check if we're in the stats page (but not song detail)
  const statsPage = document.getElementById('page-stats');
  const songDetailPane = document.getElementById('db-song-detail');
  
  if (statsPage.style.display !== 'none') {
    const text = target.textContent.trim();
    
    // If in song detail view, check if this is a date click
if (songDetailPane.classList.contains('active') && target.closest('td') && target.closest('td').cellIndex === 0) {
  // This is a date in the song detail table - show setlist
  showSetlistForDate(text);
  return;
} else {
  // Regular click from other stats tabs
  switchPageByName('jams');
  document.getElementById('search-input').value = text;
  renderFilteredJams();
}
  }
});

function showSongDetail(normSongName) {
  // Switch back to stats page first
  switchPageByName('stats');
  
  const song = dbSongs[normSongName];
  if (!song) {
    console.log("❌ Song not found in dbSongs:", normSongName);
    return;
  }
  
  console.log("🔄 showSongDetail called with:", normSongName);
  console.log("Song data:", song);
  
  currentSongDetail = { norm: normSongName, data: song };
  
  // Update header info
  document.getElementById('song-detail-title').textContent = song.name;
  document.getElementById('song-detail-count').textContent = song.performances.length;
  document.getElementById('song-detail-first').textContent = song.firstPlayed;
  document.getElementById('song-detail-last').textContent = song.lastPlayed;
  
  const lastIdx = dbDates.indexOf(song.lastPlayed);
  const currentGap = dbDates.length - 1 - lastIdx;
  document.getElementById('song-detail-gap').textContent = currentGap;
  
  // Clear the new song search input
  document.getElementById('song-detail-new-search').value = '';
  
  // Render performance table
  renderSongDetailTable();
  
  // Switch to song detail tab
  switchDbTab('song-detail');
}

function renderSongDetailTable() {
  if (!currentSongDetail) return;
  
  const tbody = document.getElementById('song-detail-tbody');
  tbody.innerHTML = '';
  
  const song = currentSongDetail.data;
  
  // Get unique dates sorted chronologically (oldest to newest)
const performanceDates = song.performances.map(p => typeof p === 'string' ? p : p.date);
const uniqueDates = [...new Set(performanceDates)].sort((a, b) => new Date(a) - new Date(b));  
  let performances = [];
  const seenPerformances = new Set();
  
  // Build performances with proper gap calculation
  uniqueDates.forEach((date, dateIndex) => {
    const show = dbShows[date];
    if (!show) return;
    
    const sets = show.sets || {};
    let occurrenceInDate = 0;
    
    Object.entries(sets).forEach(([setName, setContent]) => {
      const songs = parseDbSetlist(setContent);
      
      songs.forEach((songName, idx) => {
        let norm = normalizeSongName(songName);
        
        // SPECIAL HANDLING: Apply the same normalization as in processShowsDatabase
        if (norm.includes("to be young") || norm.includes("is to be high") || norm.includes("is to be sad")) {
          norm = "to be young is to be sad is to be high";
        }
        
        if (norm === currentSongDetail.norm) {
          const perfKey = `${date}-${setName}-${idx}`;
          
          if (!seenPerformances.has(perfKey)) {
            seenPerformances.add(perfKey);
            
            // Standardize set name
            let standardizedSetName = setName;
            if (setName.toLowerCase().includes('set1') || setName === '1') {
              standardizedSetName = 'Set 1';
            } else if (setName.toLowerCase().includes('set2') || setName === '2') {
              standardizedSetName = 'Set 2';
            } else if (setName.toLowerCase().includes('set3') || setName === '3') {
              standardizedSetName = 'Set 3';
            } else if (setName.toLowerCase().includes('encore')) {
              standardizedSetName = 'Encore';
            } else {
              standardizedSetName = setName.replace('set', 'Set ');
            }
            
            // Calculate gap
            let gap = '-';
            const isFirstOccurrence = occurrenceInDate === 0;
            
            if (isFirstOccurrence) {
              if (dateIndex === 0) {
                // First ever performance - calculate gap from start of database
                const currentDateIndex = dbDates.indexOf(date);
                gap = currentDateIndex;
              } else {
                // Subsequent performances - calculate gap from previous performance
                const currentDateIndex = dbDates.indexOf(date);
                const prevDateIndex = dbDates.indexOf(uniqueDates[dateIndex - 1]);
                gap = Math.max(0, currentDateIndex - prevDateIndex - 1);
              }
            }
            
            occurrenceInDate++;
            
            // Store chronological index for stable sorting
            const chronologicalIndex = dateIndex;
            
            performances.push({
              date,
              dateTimestamp: new Date(date).getTime(),
              chronologicalIndex,
              show,
              setName: standardizedSetName,
              position: idx,
              songBefore: idx > 0 ? songs[idx - 1].replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, '') : '-',
              songAfter: idx < songs.length - 1 ? songs[idx + 1].replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, '') : '-',
              gap: gap,
              isFirstOccurrenceOfDate: isFirstOccurrence
            });
          }
        }
      });
    });
  });
  
  // Apply sorting
  const sort = dbSortState.songDetail;
  performances.sort((a, b) => {
    let result = 0;
    
    if (sort.column === 'date') {
      // Use chronological index for stable, predictable sorting
      result = a.chronologicalIndex - b.chronologicalIndex;
      if (result === 0) {
        const setOrder = {'Set 1': 1, 'Set 2': 2, 'Set 3': 3, 'Encore': 4};
        result = (setOrder[a.setName] || 5) - (setOrder[b.setName] || 5);
        if (result === 0) {
          result = a.position - b.position;
        }
      }
    } else if (sort.column === 'venue') {
      const va = (a.show.venue || '').toLowerCase();
      const vb = (b.show.venue || '').toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    } else if (sort.column === 'gap') {
      const va = (a.gap === '-' || a.gap === '') ? -1 : parseInt(a.gap);
      const vb = (b.gap === '-' || b.gap === '') ? -1 : parseInt(b.gap);
      result = va - vb;
    } else if (sort.column === 'set') {
      const setOrder = {'Set 1': 1, 'Set 2': 2, 'Set 3': 3, 'Encore': 4};
      result = (setOrder[a.setName] || 5) - (setOrder[b.setName] || 5);
      if (result === 0) {
        result = a.position - b.position;
      }
    } else if (sort.column === 'songBefore') {
      const va = a.songBefore.toLowerCase();
      const vb = b.songBefore.toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    } else if (sort.column === 'songAfter') {
      const va = a.songAfter.toLowerCase();
      const vb = b.songAfter.toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    }
    
    return sort.direction === 'asc' ? result : -result;
  });
  
  // IMPROVED JAM MATCHING LOGIC
  const jamsForSong = allJams.filter(j => {
    const jamNorm = normalizeSongName(j.song);
    const dbNorm = currentSongDetail.norm;
    
    // Direct match
    if (jamNorm === dbNorm) return true;
    
    // Special case for "To Be Young" variations
    if ((jamNorm.includes("to be young") || jamNorm.includes("is to be high") || jamNorm.includes("is to be sad")) &&
        (dbNorm.includes("to be young") || dbNorm.includes("is to be high") || dbNorm.includes("is to be sad"))) {
      return true;
    }
    
    // Fuzzy matching for other songs - check if one contains the other
    if (jamNorm.includes(dbNorm) || dbNorm.includes(jamNorm)) {
      return true;
    }
    
    return false;
  });
  
  // Render each performance
  performances.forEach(perf => {
    const jamEntry = jamsForSong.find(j => {
      const jamDate = j.date;
      const formattedJamDate = formatDateForDisplay(jamDate);
      
      // Try multiple date formats for matching
      return jamDate === perf.date || 
             formattedJamDate === perf.date ||
             formatDateForDisplay(perf.date) === jamDate ||
             formatDateForDisplay(perf.date) === formattedJamDate;
    });
    
    const isHighlighted = jamEntry?.highlighted;
    const notes = jamEntry?.notes || '-';
    
    const tr = document.createElement('tr');
    if (isHighlighted) tr.classList.add('highlighted-row');
    
    const dateText = perf.date;
    const venueText = perf.show.venue || 'Unknown';
    
    tr.innerHTML = `
      <td><span class="clickable-filter" style="${isHighlighted ? 'font-weight:bold;' : ''}">${dateText}</span></td>
      <td><span class="clickable-filter">${venueText}</span></td>
      <td>${perf.isFirstOccurrenceOfDate ? perf.gap : ''}</td>
      <td>${perf.setName}</td>
      <td>${perf.songBefore}</td>
      <td>${perf.songAfter}</td>
      <td>${notes}</td>
    `;
    
    tbody.appendChild(tr);
  });
  
  if (performances.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;padding:2rem;color:var(--muted-color);">No performances found in setlists for this song</td></tr>';
  }
}

function sortSongDetail(column) {
  if (dbSortState.songDetail.column === column) {
    dbSortState.songDetail.direction = dbSortState.songDetail.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.songDetail.column = column;
    dbSortState.songDetail.direction = 'asc';
  }
  
  document.querySelectorAll('#db-song-detail thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('song-detail-' + column + '-sort');
  if (indicator) indicator.textContent = dbSortState.songDetail.direction === 'asc' ? '▲' : '▼';
  
  renderSongDetailTable();
}

function filterSongDetail() {
  const search = document.getElementById('song-detail-search').value.toLowerCase();
  const allRows = document.querySelectorAll('#song-detail-tbody tr');
  
  allRows.forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(search) ? '' : 'none';
  });
}

function searchNewSongFromDetail() {
  const searchValue = document.getElementById('song-detail-new-search').value.trim();
  if (!searchValue) return;
  
  // Find the song in the database
  const normSearch = normalizeSongName(searchValue);
  const song = dbSongs[normSearch];
  
  if (song) {
    // Show the song detail for the new song
    showSongDetail(normSearch);
  } else {
    // If not found, search in the main song list and switch to song history
    document.getElementById('db-song-search').value = searchValue;
    switchDbTab('songs');
    filterDbSongs();
  }
}

function switchPageByName(page) {
  document.querySelectorAll('.page-tab').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.page-content').forEach(pane => pane.style.display = 'none');
  
  document.querySelector(`.page-tab[onclick="switchPage('${page}')"]`).classList.add('active');
  document.getElementById('page-' + page).style.display = 'block';
}

function switchDbTab(tab) {
  document.querySelectorAll('.tab-button:not(.page-tab)').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
  
  if (event && event.target) {
    event.target.classList.add('active');
  } else {
    document.querySelector(`.tab-button[onclick*="${tab}"]`).classList.add('active');
  }
  document.getElementById('db-' + tab).classList.add('active');
}

// Add random show function
function showRandomSetlist() {
  const allDates = Object.keys(dbShows).filter(d => d.match(/^\d{4}-\d{2}-\d{2}/));
  const randomDate = allDates[Math.floor(Math.random() * allDates.length)];
  showSetlistForDate(randomDate);
}

document.addEventListener('DOMContentLoaded', function() {
  loadShowsDatabase();
});
</script>
</body>
</html>
