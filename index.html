<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spafford Jam Chart</title>
<style>
:root {
  --bg-color:#000;
  --card-bg:#111;
  --text-color:#f0f0f0;
  --muted-color:#999;
  --border-color:#222;
  --yellow:#ffeb3b;
  --accent-color:#b0b0b0;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:var(--bg-color);color:var(--text-color);min-height:100vh;}
.container{max-width:1200px;margin:0 auto;padding:20px;}
.site-header{text-align:center;padding:2rem 0;margin-bottom:2rem;}
.site-header h1{font-size:2.5rem;margin-bottom:0.5rem;}
.site-header p{color:var(--muted-color);}
.site-disclaimer{font-size:0.85rem;font-style:italic;margin-top:0.5rem;}
.search-container{display:flex;gap:1rem;margin-bottom:2rem;align-items:center;}
#search-input{flex:1;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
#filter-select{padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);}
.search-container input[type="text"]{flex:1;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
.jam-table-container{background:var(--card-bg);border-radius:8px;border:1px solid var(--border-color);overflow-x:auto;}
.jam-table{width:100%;border-collapse:collapse;font-size:0.9rem;}
.jam-table th:first-child,
.jam-table td:first-child{width:95px;min-width:95px;white-space:nowrap;}
.jam-table th{background:#0a0a0a;color:var(--text-color);font-weight:600;padding:1rem 0.75rem;text-align:left;border-bottom:2px solid var(--border-color);cursor:pointer;user-select:none;}
.jam-table th:hover{background:#151515;}
.jam-table td{padding:0.75rem;border-bottom:1px solid var(--border-color);line-height:1.4;vertical-align:top;}
.jam-table tr:hover{background:rgba(255,255,255,0.02);}
.jam-entry{cursor:pointer;color:var(--yellow);}
.jam-entry.highlighted{font-weight:bold;}
.highlighted-row{border-left:4px solid var(--yellow);}
.selected-row{box-shadow:0 0 0 2px rgba(255,235,59,0.3);}
.clickable-filter{cursor:pointer;transition:all 0.2s ease;color:var(--yellow);}
.clickable-filter:hover{text-decoration:underline;color:var(--accent-color);}
.status-message{text-align:center;padding:0.5rem;border-radius:4px;font-weight:bold;}
.status-message.success{color:#28a745;}
.status-message.error{color:#dc3545;}
.status-message.info{color:#17a2b8;}

/* Database Explorer Styles */
.tab-nav{display:flex;gap:0.5rem;margin-bottom:1.5rem;flex-wrap:wrap;}
.tab-button{padding:0.6rem 1.2rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);cursor:pointer;transition:all 0.2s;font-size:0.9rem;}
.tab-button:hover{background:#1a1a1a;}
.tab-button.active{background:#2a2a2a;border-color:var(--yellow);font-weight:600;}
.tab-pane{display:none;}
.tab-pane.active{display:block;}
.mini-stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:1rem;margin-bottom:1.5rem;}
.mini-stat{background:var(--card-bg);padding:1rem;border-radius:6px;border:1px solid var(--border-color);text-align:center;}
.mini-stat-value{font-size:1.8rem;font-weight:bold;color:var(--yellow);}
.mini-stat-label{color:var(--muted-color);font-size:0.85rem;margin-top:0.3rem;}
.input-group{display:flex;gap:0.5rem;margin-bottom:1rem;flex-wrap:wrap;align-items:center;}
.input-group input,.input-group select{flex:1;min-width:200px;padding:0.75rem;border-radius:8px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);font-size:1rem;}
.btn-search{padding:0.75rem 1.5rem;border-radius:6px;border:none;background:var(--yellow);color:#000;font-weight:600;cursor:pointer;transition:all 0.2s;}
.btn-search:hover{background:#ffd700;}
.result-box{background:#1a1a1a;padding:1.5rem;border-radius:6px;margin-top:1rem;white-space:pre-line;line-height:1.6;}
.page-content{display:block;}

/* Setlist Modal Styles */
.setlist-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.setlist-content {
  background: var(--card-bg);
  border: 2px solid var(--yellow);
  border-radius: 8px;
  padding: 2rem;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
  color: var(--text-color);
}

.setlist-header {
  margin-bottom: 1.5rem;
}

.setlist-date {
  color: var(--text-color);
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
}

.setlist-venue {
  color: var(--muted-color);
  font-size: 1.1rem;
  margin-bottom: 0.25rem;
}

.setlist-show-info {
  color: var(--muted-color);
  font-size: 0.9rem;
  margin-bottom: 1rem;
}

.setlist-section {
  margin-bottom: 1.5rem;
}

.setlist-section-title {
  color: var(--text-color);
  font-weight: bold;
  margin-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 0.25rem;
}

.setlist-songs {
  color: var(--text-color);
  line-height: 1.6;
}

.setlist-song {
  margin-bottom: 0.5rem;
}

.setlist-arrow {
  color: var(--text-color);
  margin: 0 0.25rem;
  font-weight: normal;
}

.setlist-notes {
  color: var(--text-color);
  line-height: 1.6;
  font-style: italic;
  border-left: 3px solid var(--yellow);
  padding-left: 1rem;
  margin-top: 1rem;
}

.setlist-close {
  background: var(--yellow);
  color: #000;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  margin-top: 1rem;
  width: 100%;
}

.setlist-close:hover {
  background: #ffd700;
}

/* Date links in table */
.date-link {
  cursor: pointer;
  text-decoration: none;
  color: var(--text-color) !important;
}

.date-link:hover {
  color: var(--yellow) !important;
}

@media(max-width:768px){.container{padding:15px;}.site-header h1{font-size:2rem;}}
</style>
</head>
<body>
<header class="site-header">
<div class="container">
<h1>Spafford Jam Chart</h1>
<p>😀 😂 😊 😎 😜</p>
<p class="site-disclaimer">Some entries may display as incomplete - working on that!</p>
<div class="tab-nav" style="margin-top:1.5rem;justify-content:center;">
  <button class="tab-button page-tab active" onclick="switchPage('jams')">Jam Chart</button>
  <button class="tab-button page-tab" onclick="switchPage('stats')">Stats</button>
</div>
</div>
</header>
<main class="container">
<div id="page-jams" class="page-content">
<div class="search-container">
<input type="text" id="search-input" placeholder="Search songs, locations, dates..." onkeyup="renderFilteredJams()">
<select id="filter-select" onchange="renderFilteredJams()">
  <option value="all">All Jams</option>
  <option value="highlighted">Highlighted</option>
</select>
</div>
<div class="jam-table-container">
<table class="jam-table">
<thead>
<tr>
<th onclick="sortTable('date')">Date <span id="date-sort">▼</span></th>
<th onclick="sortTable('song')">Song <span id="song-sort"></span></th>
<th onclick="sortTable('timing')">Timing <span id="timing-sort"></span></th>
<th onclick="sortTable('venue')">Location <span id="venue-sort"></span></th>
<th onclick="sortTable('notes')">Notes <span id="notes-sort"></span></th>
</tr>
</thead>
<tbody id="jam-table-body"></tbody>
</table>
</div>
</div>

<div id="page-stats" class="page-content" style="display:none;">
<div style="margin-bottom:2rem;">
  <h2 style="margin-bottom:1.5rem;">Database Stats</h2>
  
  <div class="tab-nav">
    <button class="tab-button active" onclick="switchDbTab('songs')">Song History</button>
    <button class="tab-button" onclick="switchDbTab('pairings')">Song Pairings</button>
    <button class="tab-button" onclick="switchDbTab('locations')">Locations</button>
    <button class="tab-button" onclick="switchDbTab('gaps')">Gap Calculator</button>
  </div>

  <div id="db-songs" class="tab-pane active">
    <div class="mini-stats">
      <div class="mini-stat">
        <div class="mini-stat-value" id="db-total-songs">-</div>
        <div class="mini-stat-label">Unique Songs</div>
      </div>
      <div class="mini-stat">
        <div class="mini-stat-value" id="db-total-shows">-</div>
        <div class="mini-stat-label">Total Shows</div>
      </div>
    </div>
    
    <div class="search-container">
      <input type="text" id="db-song-search" placeholder="Search songs..." onkeyup="filterDbSongs()">
    </div>
    
    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortDbSongs('name')" style="cursor:pointer;">Song <span id="db-songs-sort-name">▲</span></th>
            <th onclick="sortDbSongs('played')" style="cursor:pointer;">Played <span id="db-songs-sort-played"></span></th>
            <th onclick="sortDbSongs('first')" style="cursor:pointer;">First <span id="db-songs-sort-first"></span></th>
            <th onclick="sortDbSongs('last')" style="cursor:pointer;">Last <span id="db-songs-sort-last"></span></th>
            <th onclick="sortDbSongs('gap')" style="cursor:pointer;">Gap <span id="db-songs-sort-gap"></span></th>
          </tr>
        </thead>
        <tbody id="db-songs-tbody"></tbody>
      </table>
    </div>
  </div>

  <div id="db-pairings" class="tab-pane">
    <div class="input-group">
      <input type="text" id="db-pair-song1" placeholder="First song...">
      <span style="font-size:1.5rem;">→</span>
      <input type="text" id="db-pair-song2" placeholder="Second song...">
      <button class="btn-search" onclick="searchDbPairing()">Search</button>
    </div>
    <div id="db-pairing-results"></div>
  </div>

  <div id="db-locations" class="tab-pane">
    <div class="search-container">
      <input type="text" id="db-location-search" placeholder="Search cities, states, venues..." onkeyup="filterDbLocations()">
    </div>
    
    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortDbLocations('location')" style="cursor:pointer;">Location <span id="db-locations-sort-location">▲</span></th>
            <th onclick="sortDbLocations('venue')" style="cursor:pointer;">Venue <span id="db-locations-sort-venue"></span></th>
            <th onclick="sortDbLocations('shows')" style="cursor:pointer;">Shows <span id="db-locations-sort-shows"></span></th>
            <th onclick="sortDbLocations('first')" style="cursor:pointer;">First <span id="db-locations-sort-first"></span></th>
            <th onclick="sortDbLocations('last')" style="cursor:pointer;">Last <span id="db-locations-sort-last"></span></th>
          </tr>
        </thead>
        <tbody id="db-locations-tbody"></tbody>
      </table>
    </div>
  </div>

  <div id="db-gaps" class="tab-pane">
    <div style="background:var(--card-bg);padding:2rem;border-radius:8px;border:1px solid var(--border-color);">
      <h3 style="margin-bottom:1rem;">Calculate Gaps</h3>
      
      <label style="display:block;margin-bottom:0.5rem;font-weight:600;">Search for song, city, state, or venue:</label>
      <input type="text" id="db-gap-input" placeholder="e.g., Minds Unchained, Chicago, IA, Red Rocks" style="width:100%;padding:0.75rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);">
      
      <button class="btn-search" style="margin-top:1rem;width:100%;" onclick="calculateDbGap()">Calculate</button>
      
      <div id="db-gap-result" style="display:none;" class="result-box"></div>
    </div>
  </div>

  <div id="db-song-detail" class="tab-pane">
    <div style="margin-bottom:1.5rem;">
      <h3 id="song-detail-title" style="color:var(--yellow);font-size:1.8rem;margin-bottom:0.5rem;"></h3>
      <div style="display:flex;gap:2rem;flex-wrap:wrap;color:var(--muted-color);align-items:center;">
        <div>Total Performances: <strong id="song-detail-count" style="color:var(--text-color);">-</strong></div>
        <div>First Played: <strong id="song-detail-first" style="color:var(--text-color);">-</strong></div>
        <div>Last Played: <strong id="song-detail-last" style="color:var(--text-color);">-</strong></div>
        <div>Current Gap: <strong id="song-detail-gap" style="color:var(--text-color);">-</strong> shows</div>
        <input type="text" id="song-detail-new-search" placeholder="Search for another song..." style="margin-left:auto;padding:0.5rem 1rem;border-radius:6px;border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);width:200px;" onkeyup="if(event.key==='Enter') searchNewSongFromDetail()">
      </div>
    </div>

    <div class="search-container">
      <input type="text" id="song-detail-search" placeholder="Filter dates, venues..." onkeyup="filterSongDetail()" style="flex:1;">
    </div>

    <div class="jam-table-container">
      <table class="jam-table">
        <thead>
          <tr>
            <th onclick="sortSongDetail('date')">Date <span id="song-detail-date-sort">▲</span></th>
            <th onclick="sortSongDetail('venue')">Venue <span id="song-detail-venue-sort"></span></th>
            <th onclick="sortSongDetail('gap')">Gap <span id="song-detail-gap-sort"></span></th>
            <th onclick="sortSongDetail('set')">Set <span id="song-detail-set-sort"></span></th>
            <th onclick="sortSongDetail('songBefore')">Song Before</th>
            <th onclick="sortSongDetail('songAfter')">Song After</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody id="song-detail-tbody"></tbody>
      </table>
    </div>
  </div>
</div>
</div>

</main>
<script>
// JAM CHART CODE
let allJams = [];
let currentSort = {column:'date',direction:'desc'};
const tableBody = document.getElementById('jam-table-body');

function formatDateForDisplay(dateStr) {
  if (!dateStr) return '';
  try {
    let month, day, year;
    
    if (dateStr.includes('-') && dateStr.split('-')[0].length === 4) {
      [year, month, day] = dateStr.split('-').map(Number);
    } 
    else if (dateStr.includes('/')) {
      [month, day, year] = dateStr.split('/').map(Number);
    }
    else {
      return dateStr;
    }
    
    const monthStr = month.toString().padStart(2, '0');
    const dayStr = day.toString().padStart(2, '0');
    return `${monthStr}-${dayStr}-${year}`;
  } catch {
    return dateStr;
  }
}

function loadJams(){
  console.log('Loading jams.json...');
  fetch('jams.json')
  .then(r=>{
    console.log('Jams response:', r.status);
    return r.json();
  })
  .then(data=>{
    console.log('Jams loaded:', data.length, 'entries');
    
    // Process jams to add setlist order information
    const processedJams = [];
    
    data.forEach(entry => {
      entry.date = entry.date||'';
      entry.song = entry.song||'';
      entry.timing = entry.timing||'';
      entry.venue = entry.venue||'';
      entry.notes = entry.notes||'';
      entry.highlighted = !!entry.highlighted;
      
      // Try to find this jam in the setlist to get its position
      let setOrder = 99; // Default high value for sorting
      let positionInSet = 999;
      let foundSetName = '';
      
      // Convert date to match database format if needed
      const dbDate = entry.date.includes('-') && entry.date.split('-')[0].length === 4 
        ? entry.date 
        : (() => {
            // Handle MM-DD-YYYY format
            const [month, day, year] = entry.date.split('-');
            return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
          })();
      
      if (dbShows[dbDate]) {
        const show = dbShows[dbDate];
        const sets = show.sets || {};
        
        console.log(`🔍 Checking date: ${dbDate}`);
        console.log('Available sets:', Object.keys(sets));
        
        // Create an array of set entries and sort them by set order
        const setEntries = Object.entries(sets);
        
        // Sort sets by set name to ensure correct order
        setEntries.sort((a, b) => {
          const getSetNumber = (setName) => {
            setName = setName.toLowerCase();
            if (setName.includes('set1') || setName === '1' || setName === 'Set 1') return 1;
            if (setName.includes('set2') || setName === '2' || setName === 'Set 2') return 2;
            if (setName.includes('set3') || setName === '3' || setName === 'Set 3') return 3;
            if (setName.includes('encore')) return 4;
            if (setName.includes('set')) {
              // Extract number from "setX"
              const match = setName.match(/set\s*(\d+)/i);
              return match ? parseInt(match[1]) : 99;
            }
            return 99;
          };
          
          return getSetNumber(a[0]) - getSetNumber(b[0]);
        });
        
        console.log('Sorted sets:', setEntries.map(([name]) => name));
        
        // Now search through sets in correct order
        let found = false;
        for (const [setName, setContent] of setEntries) {
          console.log(`📋 Set ${setName}:`, setContent);
          const songs = parseDbSetlist(setContent);
          console.log(`🎵 Parsed songs in ${setName}:`, songs);
          
          const jamSongNorm = normalizeSongName(entry.song);
          console.log(`🎯 Looking for: "${entry.song}" (normalized: "${jamSongNorm}")`);
          
          for (let songIndex = 0; songIndex < songs.length; songIndex++) {
            const setlistSong = songs[songIndex];
            const setlistSongNorm = normalizeSongName(setlistSong);
            
            console.log(`   Comparing with: "${setlistSong}" (normalized: "${setlistSongNorm}")`);
            
            // Exact match
            if (setlistSongNorm === jamSongNorm) {
              found = true;
              foundSetName = setName;
              
              // Standardize set order
              if (setName.toLowerCase().includes('set1') || setName === '1' || setName === 'Set 1') setOrder = 1;
              else if (setName.toLowerCase().includes('set2') || setName === '2' || setName === 'Set 2') setOrder = 2;
              else if (setName.toLowerCase().includes('set3') || setName === '3' || setName === 'Set 3') setOrder = 3;
              else if (setName.toLowerCase().includes('encore')) setOrder = 4;
              else if (setName.toLowerCase().includes('set')) {
                // Extract number from "setX"
                const match = setName.toLowerCase().match(/set\s*(\d+)/);
                setOrder = match ? parseInt(match[1]) : 99;
              }
              
              positionInSet = songIndex;
              console.log(`✅ FOUND: "${entry.song}" in set ${setName} at position ${positionInSet} (order: ${setOrder})`);
              break;
            }
          }
          if (found) break; // Found it, stop searching
        }
        
        if (!found) {
          console.log(`❌ NOT FOUND: "${entry.song}" in any set for ${dbDate}`);
          // Let's try a more aggressive search
          console.log('🔄 Trying aggressive search...');
          for (const [setName, setContent] of setEntries) {
            const songs = parseDbSetlist(setContent);
            for (let songIndex = 0; songIndex < songs.length; songIndex++) {
              const setlistSong = songs[songIndex];
              const setlistSongNorm = normalizeSongName(setlistSong);
              const jamSongNorm = normalizeSongName(entry.song);
              
              // Check if either string contains the other
              if (setlistSongNorm.includes(jamSongNorm) || jamSongNorm.includes(setlistSongNorm)) {
                console.log(`🔄 PARTIAL MATCH: "${entry.song}" ≈ "${setlistSong}"`);
                found = true;
                foundSetName = setName;
                
                // Standardize set order (same as above)
                if (setName.toLowerCase().includes('set1') || setName === '1' || setName === 'Set 1') setOrder = 1;
                else if (setName.toLowerCase().includes('set2') || setName === '2' || setName === 'Set 2') setOrder = 2;
                else if (setName.toLowerCase().includes('set3') || setName === '3' || setName === 'Set 3') setOrder = 3;
                else if (setName.toLowerCase().includes('encore')) setOrder = 4;
                else if (setName.toLowerCase().includes('set')) {
                  const match = setName.toLowerCase().match(/set\s*(\d+)/);
                  setOrder = match ? parseInt(match[1]) : 99;
                }
                
                positionInSet = songIndex;
                console.log(`✅ AGGRESSIVE FOUND: "${entry.song}" in set ${setName} at position ${positionInSet}`);
                break;
              }
            }
            if (found) break;
          }
        }
      } else {
        console.log(`❌ NO SHOW DATA: No show data for date ${dbDate}`);
      }
      
      // Add setlist order info to the entry
      entry.setOrder = setOrder;
      entry.positionInSet = positionInSet;
      entry.dbDate = dbDate; // Store the database date for debugging
      
      const tr = document.createElement('tr');
      if(entry.highlighted) tr.classList.add('highlighted-row');
      const songSpan = document.createElement('span');
      songSpan.textContent = entry.song;
      songSpan.className = 'jam-entry' + (entry.highlighted?' highlighted':'');
      songSpan.classList.add('clickable-filter');
	// Look up location from shows database
let locationText = entry.venue; // fallback to venue name
try {
  const dbDate = entry.dbDate || (entry.date.includes('-') && entry.date.split('-')[0].length === 4 
    ? entry.date 
    : (() => {
        const [month, day, year] = entry.date.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      })());
  
  if (dbShows[dbDate]) {
    const show = dbShows[dbDate];
    locationText = `${show.city || 'Unknown'}, ${show.state || ''}`.trim();
    if (locationText.endsWith(',')) locationText = locationText.slice(0, -1);
  }
} catch (e) {
  console.log('Error getting location for', entry.date, e);
}

tr.innerHTML = `
  <td><span class="date-link" data-date="${entry.date}" style="cursor: pointer; color: var(--text-color);">${formatDateForDisplay(entry.date)}</span></td>
  <td></td>
  <td>${entry.timing}</td>
  <td><span class="clickable-filter">${locationText}</span></td>
  <td>${entry.notes}</td>
`;
      tr.children[1].appendChild(songSpan);
      entry.element = tr;
      processedJams.push(entry);
    });
    
    allJams = processedJams;
    
    // HARDCODE 2025-01-17 order
    const jan17Order = [
      "Neutrino", "Peaches", "Broken Wing", "Fake the Fate", "Levilan Shores",
      "Ain't That Wrong", "Pursuit of Trance", "Down Under", "Can't Find My Vape", "Galisteo Way", 
      "Frog Gossip"
    ];

    allJams.forEach(jam => {
      if (jam.date === '01-17-2025' || jam.dbDate === '2025-01-17') {
        const orderIndex = jan17Order.indexOf(jam.song);
        jam.hardcodedOrder = orderIndex >= 0 ? orderIndex : 999;
        console.log(`🔧 Hardcoded order for ${jam.song}: ${jam.hardcodedOrder}`);
      } else {
        jam.hardcodedOrder = 999; // Default high value for other shows
      }
    });
    
    // Debug: Show the order for 2025-01-17
    const jan17Jams = allJams.filter(j => j.dbDate === '2025-01-17');
    console.log('🎪 2025-01-17 Jams with set order BEFORE sorting:');
    jan17Jams.forEach(jam => {
      console.log(`   "${jam.song}" - Set: ${jam.setOrder}, Position: ${jam.positionInSet}, Hardcoded: ${jam.hardcodedOrder}`);
    });
    
    sortTable('date');
  })
  .catch(err=>{
    console.error("Failed to load jams.json:",err);
    tableBody.innerHTML='<tr><td colspan="5" style="text-align:center;color:var(--muted-color);padding:2rem;">Failed to load jams.json</td></tr>';
  });
}

function renderFilteredJams(){
  const searchTerm = document.getElementById('search-input').value.toLowerCase();
  const filterVal = document.getElementById('filter-select').value;

  const filtered = allJams.filter(j=>{
    if(filterVal==='highlighted' && !j.highlighted) return false;
    if(!searchTerm) return true;
    // Look up location for search
let locationText = j.venue; // fallback
try {
  const dbDate = j.dbDate || (j.date.includes('-') && j.date.split('-')[0].length === 4 
    ? j.date 
    : (() => {
        const [month, day, year] = j.date.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      })());
  
  if (dbShows[dbDate]) {
    const show = dbShows[dbDate];
    locationText = `${show.city || 'Unknown'}, ${show.state || ''}`.trim();
    if (locationText.endsWith(',')) locationText = locationText.slice(0, -1);
  }
} catch (e) {
  console.log('Error getting location for search:', j.date, e);
}

return j.song.toLowerCase().includes(searchTerm) ||
       locationText.toLowerCase().includes(searchTerm) ||
       j.date.includes(searchTerm) ||
       j.notes.toLowerCase().includes(searchTerm);
  });

  const frag = document.createDocumentFragment();
  filtered.forEach(j=>frag.appendChild(j.element));
  tableBody.innerHTML='';
  tableBody.appendChild(frag);

  if(filtered.length===0)
    tableBody.innerHTML='<tr><td colspan="5" style="text-align:center;color:var(--muted-color);padding:2rem;">No jams found matching your criteria.</td></tr>';
}

function sortTable(column){
  if(!allJams.length) return;
  if(currentSort.column===column) currentSort.direction = currentSort.direction==='asc'?'desc':'asc';
  else {currentSort.column=column; currentSort.direction='asc';}

  console.log(`🔄 Sorting by ${column} ${currentSort.direction}`);
  
  allJams.sort((a,b)=>{
    // HARDCODED ORDER for 2025-01-17 - FORCE this order regardless of other sorting
    if ((a.date === '01-17-2025' || a.dbDate === '2025-01-17') && 
        (b.date === '01-17-2025' || b.dbDate === '2025-01-17')) {
      const result = a.hardcodedOrder - b.hardcodedOrder;
      console.log(`🔧 Hardcoded sort: "${a.song}" (${a.hardcodedOrder}) vs "${b.song}" (${b.hardcodedOrder}) = ${result}`);
      return result;
    }
    
    let va=a[column], vb=b[column];
    
    if(column==='date'){
      const parseDate = (dateStr) => {
        try {
          if (dateStr.includes('-')) {
            return new Date(dateStr).getTime();
          }
          const [m,d,y] = dateStr.split('/').map(Number);
          return new Date(y,m-1,d).getTime();
        } catch {
          return 0;
        }
      };
      va = parseDate(va);
      vb = parseDate(vb);
      
      // If dates are equal, sort by set order and position in set
      if (va === vb) {
        if (a.setOrder !== b.setOrder) {
          console.log(`   Same date, different set order: "${a.song}" (set ${a.setOrder}) vs "${b.song}" (set ${b.setOrder})`);
          return a.setOrder - b.setOrder;
        }
        if (a.positionInSet !== b.positionInSet) {
          console.log(`   Same date and set, different position: "${a.song}" (pos ${a.positionInSet}) vs "${b.song}" (pos ${b.positionInSet})`);
          return a.positionInSet - b.positionInSet;
        }
        console.log(`   Same date, set, and position: "${a.song}" vs "${b.song}"`);
        return 0;
      }
    } else if(column==='timing'){
      const parseTime = (timeStr) => {
        if (!timeStr || typeof timeStr !== 'string') return 0;
        const parts = timeStr.split(':');
        const minutes = parseInt(parts[0]) || 0;
        const seconds = parseInt(parts[1]) || 0;
        return minutes * 60 + seconds;
      };
      va = parseTime(va);
      vb = parseTime(vb);
    } else {
      va = va.toString().toLowerCase(); 
      vb = vb.toString().toLowerCase();
    }
    
    const result = currentSort.direction==='asc'? (va<vb?-1:va>vb?1:0) : (va<vb?1:va>vb?-1:0);
    
    if (column === 'date' && a.date === '01-17-2025' && b.date === '01-17-2025') {
      console.log(`   Comparing "${a.song}" vs "${b.song}": ${result}`);
    }
    
    return result;
  });

  document.querySelectorAll('[id$="-sort"]').forEach(ind=>ind.textContent='');
  const curr=document.getElementById(currentSort.column+'-sort');
  if(curr) curr.textContent=currentSort.direction==='asc'?'▲':'▼';
  
  console.log('🎪 Final order for 2025-01-17:');
  allJams.filter(j => j.date === '01-17-2025').forEach((jam, index) => {
    console.log(`   ${index + 1}. "${jam.song}" - Hardcoded: ${jam.hardcodedOrder}`);
  });
  
  renderFilteredJams();
}

// SETLIST MODAL FUNCTION - FIXED VERSION
function showSetlistForDate(date) {
  // Convert date format if needed (MM-DD-YYYY to YYYY-MM-DD)
  const dbDate = date.includes('-') && date.split('-')[0].length === 4 
    ? date 
    : (() => {
        const [month, day, year] = date.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      })();
  
  const show = dbShows[dbDate];
  if (!show) {
    alert(`No setlist data found for ${date}`);
    return;
  }
  
  // Get jam data for this date to check which songs are highlighted
  const jamEntries = allJams.filter(jam => 
    jam.date === date || jam.dbDate === dbDate
  );
  
  // Format date for display (Month Date, Year)
  const displayDate = new Date(dbDate).toLocaleDateString('en-US', {
    month: 'long',
    day: 'numeric',
    year: 'numeric'
  });
  
  let setlistHTML = `
    <div class="setlist-header">
      <div class="setlist-date">${displayDate}</div>
      <div class="setlist-venue">${show.venue}, ${show.city}, ${show.state}</div>
      ${show.tour ? `<div class="setlist-show-info">${show.tour} • Show ${show.show_number || '?'}</div>` : ''}
    </div>
  `;
  
  // Setlist section
  setlistHTML += `<div class="setlist-section">
    <div class="setlist-section-title">Setlist</div>
    <div class="setlist-songs">`;
  
  // Process each set and highlight jam-charted songs - FIXED ARROW HANDLING
  const setOrder = ['Set 1', 'Set 2', 'Set 3', 'Encore'];
  
  const processSetContent = (content) => {
    if (!content) return '';
    
    // First, highlight jam-charted songs
    let processed = content;
    
    jamEntries.forEach(jam => {
      const regex = new RegExp(`\\b${jam.song.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'g');
      const style = jam.highlighted ? 
        'color: var(--yellow); font-weight: bold;' : 
        'color: var(--yellow);';
      processed = processed.replace(regex, `<span style="${style}">${jam.song}</span>`);
    });
    
    // Then add arrow styling
    processed = processed
      .replace(/->/g, '<span class="setlist-arrow">→</span>')
      .replace(/>/g, '<span class="setlist-arrow">></span>');
    
    return processed;
  };
  
  setOrder.forEach(setName => {
    if (show.sets[setName]) {
      const processedContent = processSetContent(show.sets[setName]);
      setlistHTML += `<div class="setlist-song"><strong>${setName}:</strong> ${processedContent}</div>`;
    }
  });
  
  // Also check for any other set names
  Object.keys(show.sets).forEach(setName => {
    if (!setOrder.includes(setName)) {
      const processedContent = processSetContent(show.sets[setName]);
      setlistHTML += `<div class="setlist-song"><strong>${setName}:</strong> ${processedContent}</div>`;
    }
  });
  
  setlistHTML += `</div></div>`;
  
  // Notes/Review section - get from database
  if (show.notes && show.notes.length > 0) {
    setlistHTML += `<div class="setlist-section">
      <div class="setlist-section-title">Review</div>
      <div class="setlist-notes">${show.notes.join('<br><br>')}</div>
    </div>`;
  }
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'setlist-modal';
  modal.innerHTML = `
    <div class="setlist-content">
      ${setlistHTML}
      <button class="setlist-close" onclick="this.closest('.setlist-modal').remove()">Close</button>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Close modal when clicking outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// FIXED CLICK HANDLERS - dates don't trigger search
tableBody.addEventListener('click', e => {
  let target = e.target;
  
  // Handle date clicks for setlist modal
  /*
	if (target.classList.contains('date-link')) {
  const date = target.getAttribute('data-date');
  showSetlistForDate(date);
  e.stopPropagation(); // Prevent triggering search
  return;
}
*/
  
  // Handle regular clickable filters for search
  target = e.target.closest('.clickable-filter');
  if(!target) return;
  
  // Remove any selected-row highlights
  document.querySelectorAll('.selected-row').forEach(row => row.classList.remove('selected-row'));
  
  document.getElementById('search-input').value = target.textContent.trim();
  renderFilteredJams();
});

// DATABASE EXPLORER CODE
let dbShows = {};
let dbSongs = {};
let dbLocations = {};
let dbSongRows = [];
let dbLocationRows = [];
let dbDates = [];
let dbSortState = { 
  songs: {column:'name',direction:'asc'}, 
  locations: {column:'location',direction:'asc'}, 
  songDetail: {column:'date',direction:'asc'} 
};
let currentSongDetail = null;
let songDetailRows = [];

function switchPage(page) {
  document.querySelectorAll('.page-tab').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.page-content').forEach(pane => pane.style.display = 'none');
  
  event.target.classList.add('active');
  document.getElementById('page-' + page).style.display = 'block';
}

function parseDbSetlist(str) {
  if (!str || typeof str !== 'string') return [];

  // Step 0: strip obvious junk
  str = str.trim();
  if (!str) return [];

  // Step 1: protect known multi-part and tricky names
  str = str
    .replace(/Smooth,\s*Relax,\s*Down/gi, '|||SMOOTH_RELAX_DOWN|||')
    .replace(/\bMotel\s*(?:6)?\b/gi, '|||MOTEL_6|||')
    .replace(/April\s*29,\s*1992\s*\(Miami\)/gi, '|||APRIL_MIAMI|||');

  // Step 2: sanitize loose segues and commas
  str = str
    .replace(/\s*>\s*/g, '|||')                // replace '>' segues
    .replace(/,+/g, ', ')                      // collapse repeated commas
    .replace(/,\s*(?=[A-Z0-9\[])/g, '|||');    // split on commas before new song titles

  // Step 3: remove leading/trailing separators that cause blanks
  str = str.replace(/^(\|)+|(\|)+$/g, '');

  // Step 4: split and deeply clean each song
  const songs = str
    .split(/\|\|\|/)
    .map(s => s.trim())
    .filter(s => s && /[a-z]/i.test(s)) // ensure it contains letters
    .filter(s => !/^set\s*\d*$/i.test(s)) // skip "Set 1" etc.
    .filter(s => s.toLowerCase() !== 'unknown');

  // Step 5: restore protected names
  return songs.map(s =>
    s
      .replace(/SMOOTH_RELAX_DOWN/gi, 'Smooth, Relax, Down')
      .replace(/MOTEL_6/gi, 'Motel 6')
      .replace(/APRIL_MIAMI/gi, 'April 29, 1992 (Miami)')
  );
}


function normalizeSongName(s) {
  if (!s) return "";
  s = s.trim();

  // Normalize Unicode punctuation → ASCII
  s = s
    .normalize("NFKD")                    // canonical decomposition
    .replace(/[‘’‚‛]/g, "'")              // single quotes → '
    .replace(/[“”„‟]/g, '"')              // double quotes → "
    .replace(/[‐-‒–—―]/g, "-")            // dashes → -
    .replace(/\s+/g, " ");                // collapse spaces

  // Handle special multi-part titles
  if (/smooth.*relax.*down/i.test(s)) return "smooth relax down";
  if (/motel(\s*6)?/i.test(s)) return "motel 6";
  if (/april.*1992.*miami/i.test(s)) return "april 29 1992 miami";

  // Clean general junk and lowercase
  s = s
    .replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, "")
    .replace(/\s*\(\s*[\d:\-]+\s*\)\s*/g, "")
    .replace(/[|]+/g, " ")
    .replace(/[^\w\s,()'-]/g, "")
    .replace(/'/g, "")  // REMOVE APOSTROPHES for consistent matching
    .replace(/\s+/g, " ")
    .toLowerCase()
    .trim();

  return s;
}

function loadShowsDatabase() {
  console.log('Loading shows_database.json...');
  fetch('shows_database.json')
    .then(r => {
      console.log('Shows database response:', r.status);
      return r.json();
    })
    .then(data => {
      console.log('Shows database loaded:', Object.keys(data).length, 'shows');
      dbShows = data;
      processShowsDatabase();
      renderDbSongs();
      renderDbLocations();
      // Now that dbShows is loaded, load the jams
      loadJams();
    })
    .catch(err => {
      console.error('Failed to load shows_database.json:', err);
      document.getElementById('db-songs-tbody').innerHTML = 
        '<tr><td colspan="5" style="text-align:center;padding:2rem;color:var(--muted-color);">Failed to load shows_database.json</td></tr>';
    });
}

function processShowsDatabase() {
  const songs = {};
  const locations = {};
  dbDates = Object.keys(dbShows)
    .filter(d => d.match(/^\d{4}-\d{2}-\d{2}/))
    .sort();

  dbDates.forEach(date => {
    const show = dbShows[date];
    const venue = show.venue || "Unknown";
    const city = show.city || "Unknown";
    const state = show.state || "";
    const locationKey = `${city}, ${state}`.trim();

    if (!locations[locationKey]) {
      locations[locationKey] = {
        venue,
        shows: [],
        firstShow: date,
        lastShow: date,
      };
    }
    locations[locationKey].shows.push(date);
    locations[locationKey].lastShow = date;

    const sets = show.sets || {};
    Object.values(sets).forEach(setContent => {
      const songList = parseDbSetlist(setContent);
      songList.forEach(song => {
        let norm = normalizeSongName(song);
        let displayName = song.trim()
          .replace(/^[\s|]+/, "")
          .replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, "")
          .replace(/\s*\(\s*[\d:\-]+\s*\)\s*/g, "")
          .replace(/[,\s]+$/, "")
          .trim();

        // SPECIAL HANDLING: Merge all variations of "To Be Young..."
        if (norm.includes("to be young") || norm.includes("is to be high") || norm.includes("is to be sad")) {
          norm = "to be young is to be sad is to be high";
          displayName = "To Be Young (Is to Be Sad, Is to Be High)";
        }
        
        if (norm.includes("april 29 1992 miami")) displayName = "April 29, 1992 (Miami)";
        else if (norm.includes("smooth relax down")) displayName = "Smooth, Relax, Down";
        else if (norm.includes("motel 6")) displayName = "Motel 6";

        if (!songs[norm]) {
          songs[norm] = {
            name: displayName,
            performances: [],
            firstPlayed: date,
            lastPlayed: date,
          };
        }

        // Instead of just pushing the date, push an object with the date
// This allows us to count total performances, not just unique dates
songs[norm].performances.push({
  date: date,
  // We can add more info here if needed, like set position
});
        if (new Date(date) < new Date(songs[norm].firstPlayed))
          songs[norm].firstPlayed = date;
        if (new Date(date) > new Date(songs[norm].lastPlayed))
          songs[norm].lastPlayed = date;
      });
    });
  });

  // 💥 FINAL CROSS-MERGE: collapse any duplicates that slipped through
const merged = {};
Object.values(songs).forEach(song => {
  // Extra-strict normalization of merge key
  const key = normalizeSongName(song.name).replace(/[^\w\s]/g, "").trim();
  if (!key) return;

  if (!merged[key]) {
    merged[key] = {
      name: song.name,
      performances: [...song.performances],
      firstPlayed: song.firstPlayed,
      lastPlayed: song.lastPlayed,
    };
  } else {
    merged[key].performances.push(...song.performances);
    merged[key].performances = [...new Set(merged[key].performances)].sort(
      (a, b) => new Date(a) - new Date(b)
    );
    if (new Date(song.firstPlayed) < new Date(merged[key].firstPlayed))
      merged[key].firstPlayed = song.firstPlayed;
    if (new Date(song.lastPlayed) > new Date(merged[key].lastPlayed))
      merged[key].lastPlayed = song.lastPlayed;
  }
});


  dbSongs = merged;
  dbLocations = locations;

  document.getElementById("db-total-songs").textContent = Object.keys(merged).length;
  document.getElementById("db-total-shows").textContent = dbDates.length;
}

function renderDbSongs() {
  const tbody = document.getElementById('db-songs-tbody');
  tbody.innerHTML = '';
  dbSongRows = [];
  
  let sortedSongs = Object.entries(dbSongs);
  
  // Apply sorting
  const sort = dbSortState.songs;
  sortedSongs.sort((a, b) => {
    let va, vb;
    if (sort.column === 'name') {
      va = a[1].name.toLowerCase();
      vb = b[1].name.toLowerCase();
    } else if (sort.column === 'played') {
      va = a[1].performances.length;
      vb = b[1].performances.length;
    } else if (sort.column === 'first') {
      va = new Date(a[1].firstPlayed).getTime();
      vb = new Date(b[1].firstPlayed).getTime();
    } else if (sort.column === 'last') {
      va = new Date(a[1].lastPlayed).getTime();
      vb = new Date(b[1].lastPlayed).getTime();
    } else if (sort.column === 'gap') {
      const aLastIdx = dbDates.indexOf(a[1].lastPlayed);
      const bLastIdx = dbDates.indexOf(b[1].lastPlayed);
      va = dbDates.length - 1 - aLastIdx;
      vb = dbDates.length - 1 - bLastIdx;
    }
    
    return sort.direction === 'asc' ? (va < vb ? -1 : va > vb ? 1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });
  
  sortedSongs.forEach(([norm, data]) => {
    const lastIdx = dbDates.indexOf(data.lastPlayed);
    const currentGap = dbDates.length - 1 - lastIdx;
    
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter song-name-link" data-song-norm="${norm}">${data.name}</span></td>
      <td>${data.performances.length}</td>
      <td><span class="clickable-filter">${data.firstPlayed}</span></td>
      <td><span class="clickable-filter">${data.lastPlayed}</span></td>
      <td>${currentGap}</td>
    `;
    dbSongRows.push({ element: tr, data });
    tbody.appendChild(tr);
  });
}

function sortDbSongs(column) {
  if (dbSortState.songs.column === column) {
    dbSortState.songs.direction = dbSortState.songs.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.songs.column = column;
    dbSortState.songs.direction = 'asc';
  }
  
  document.querySelectorAll('#db-songs thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('db-songs-sort-' + column);
  if (indicator) indicator.textContent = dbSortState.songs.direction === 'asc' ? '▲' : '▼';
  
  renderDbSongs();
  filterDbSongs();
}

function renderDbLocations() {
  const tbody = document.getElementById('db-locations-tbody');
  tbody.innerHTML = '';
  dbLocationRows = [];
  
  let sortedLocations = Object.entries(dbLocations);
  
  // Apply sorting
  const sort = dbSortState.locations;
  sortedLocations.sort((a, b) => {
    let va, vb;
    if (sort.column === 'location') {
      va = a[0].toLowerCase();
      vb = b[0].toLowerCase();
    } else if (sort.column === 'venue') {
      va = a[1].venue.toLowerCase();
      vb = b[1].venue.toLowerCase();
    } else if (sort.column === 'shows') {
      va = a[1].shows.length;
      vb = b[1].shows.length;
    } else if (sort.column === 'first') {
      va = new Date(a[1].firstShow).getTime();
      vb = new Date(b[1].firstShow).getTime();
    } else if (sort.column === 'last') {
      va = new Date(a[1].lastShow).getTime();
      vb = new Date(b[1].lastShow).getTime();
    }
    
    return sort.direction === 'asc' ? (va < vb ? -1 : va > vb ? 1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });
  
  sortedLocations.forEach(([location, data]) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="clickable-filter">${location}</span></td>
      <td><span class="clickable-filter">${data.venue}</span></td>
      <td>${data.shows.length}</td>
      <td><span class="clickable-filter">${data.firstShow}</span></td>
      <td><span class="clickable-filter">${data.lastShow}</span></td>
    `;
    dbLocationRows.push({ element: tr, location, data });
    tbody.appendChild(tr);
  });
}

function sortDbLocations(column) {
  if (dbSortState.locations.column === column) {
    dbSortState.locations.direction = dbSortState.locations.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.locations.column = column;
    dbSortState.locations.direction = 'asc';
  }
  
  document.querySelectorAll('#db-locations thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('db-locations-sort-' + column);
  if (indicator) indicator.textContent = dbSortState.locations.direction === 'asc' ? '▲' : '▼';
  
  renderDbLocations();
  filterDbLocations();
}

function filterDbSongs() {
  const search = document.getElementById('db-song-search').value.toLowerCase();
  const tbody = document.getElementById('db-songs-tbody');
  tbody.innerHTML = '';
  
  dbSongRows
    .filter(row => !search || row.data.name.toLowerCase().includes(search))
    .forEach(row => tbody.appendChild(row.element));
}

function filterDbLocations() {
  const search = document.getElementById('db-location-search').value.toLowerCase();
  const tbody = document.getElementById('db-locations-tbody');
  tbody.innerHTML = '';
  
  dbLocationRows
    .filter(row => !search || 
      row.location.toLowerCase().includes(search) ||
      row.data.venue.toLowerCase().includes(search))
    .forEach(row => tbody.appendChild(row.element));
}

function searchDbPairing() {
  const song1 = document.getElementById('db-pair-song1').value.trim();
  const song2 = document.getElementById('db-pair-song2').value.trim();
  const resultsDiv = document.getElementById('db-pairing-results');
  
  if (!song1 || !song2) {
    resultsDiv.innerHTML = '<div class="result-box">Please enter both song names</div>';
    return;
  }
  
  const norm1 = normalizeSongName(song1);
  const norm2 = normalizeSongName(song2);
  const sequences = [];
  const coAppearances = [];
  
  dbDates.forEach(date => {
    const show = dbShows[date];
    const sets = show.sets || {};
    let foundSequence = false;
    let found1 = false, found2 = false;
    
    Object.values(sets).forEach(setContent => {
      const songs = parseDbSetlist(setContent);
      const normalized = songs.map(s => normalizeSongName(s));
      
      for (let i = 0; i < normalized.length - 1; i++) {
        if (normalized[i] === norm1 && normalized[i + 1] === norm2) {
          foundSequence = true;
          break;
        }
      }
      
      if (normalized.includes(norm1)) found1 = true;
      if (normalized.includes(norm2)) found2 = true;
    });
    
    if (foundSequence) {
      sequences.push({ date, venue: `${show.venue}, ${show.city}, ${show.state}` });
    } else if (found1 && found2) {
      coAppearances.push({ date, venue: `${show.venue}, ${show.city}, ${show.state}` });
    }
  });
  
  if (sequences.length > 0) {
    resultsDiv.innerHTML = `
      <div class="result-box">
        <strong>Found ${sequences.length} "${song1} → ${song2}" sequence(s):</strong><br><br>
        ${sequences.map(m => `${m.date} - ${m.venue}`).join('<br>')}
      </div>
    `;
  } else if (coAppearances.length > 0) {
    resultsDiv.innerHTML = `
      <div class="result-box">
        <strong>No direct sequences, but found ${coAppearances.length} show(s) with both songs:</strong><br><br>
        ${coAppearances.map(m => `${m.date} - ${m.venue}`).join('<br>')}
      </div>
    `;
  } else {
    resultsDiv.innerHTML = '<div class="result-box">No pairings or co-appearances found</div>';
  }
}

function calculateDbGap() {
  const input = document.getElementById('db-gap-input').value.trim();
  const resultDiv = document.getElementById('db-gap-result');
  
  if (!input) {
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = 'Please enter a song, city, state, or venue';
    return;
  }
  
  // Try matching as a song first
  const normInput = normalizeSongName(input);
  if (dbSongs[normInput]) {
    const song = dbSongs[normInput];
    
    // Get unique dates only
    const uniqueDates = [...new Set(song.performances)];
    
    if (uniqueDates.length < 2) {
      resultDiv.style.display = 'block';
      resultDiv.innerHTML = `"${song.name}" has only been played ${uniqueDates.length} time(s)`;
      return;
    }
    
    const recent = uniqueDates[uniqueDates.length - 1];
    const previous = uniqueDates[uniqueDates.length - 2];
    const recentShow = dbShows[recent];
    const prevShow = dbShows[previous];
    
    const showGap = dbDates.indexOf(recent) - dbDates.indexOf(previous) - 1;
    const dayGap = Math.floor((new Date(recent) - new Date(previous)) / (1000 * 60 * 60 * 24));
    
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = `<strong>GAP ANALYSIS: ${song.name}</strong>

Most Recent:  ${recent}
Venue:        ${recentShow.venue}, ${recentShow.city}, ${recentShow.state}

Previous:     ${previous}
Venue:        ${prevShow.venue}, ${prevShow.city}, ${prevShow.state}

<strong>GAP:</strong>
Shows:        ${showGap} shows between
Days:         ${dayGap} days
Total Played: ${uniqueDates.length} times`;
    return;
  }
  
  // Try matching as state, city, or venue
  let matchingShows = [];
  const upperInput = input.toUpperCase();
  const lowerInput = input.toLowerCase();
  
  // Check if it's a state code (2 letters)
  if (input.length === 2) {
    matchingShows = dbDates.filter(d => dbShows[d].state?.toUpperCase() === upperInput);
  }
  
  // If no state matches, try city
  if (matchingShows.length === 0) {
    matchingShows = dbDates.filter(d => 
      dbShows[d].city?.toLowerCase().includes(lowerInput)
    );
  }
  
  // If still no matches, try venue
  if (matchingShows.length === 0) {
    matchingShows = dbDates.filter(d => 
      dbShows[d].venue?.toLowerCase().includes(lowerInput)
    );
  }
  
  if (matchingShows.length < 2) {
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = `Only ${matchingShows.length} show(s) found for "${input}"`;
    return;
  }
  
  const recent = matchingShows[matchingShows.length - 1];
  const previous = matchingShows[matchingShows.length - 2];
  
  const recentShow = dbShows[recent];
  const prevShow = dbShows[previous];
  
  const showGap = dbDates.indexOf(recent) - dbDates.indexOf(previous) - 1;
  const dayGap = Math.floor((new Date(recent) - new Date(previous)) / (1000 * 60 * 60 * 24));
  
  resultDiv.style.display = 'block';
  resultDiv.innerHTML = `<strong>GAP ANALYSIS: ${input}</strong>

Most Recent:  ${recent}
Venue:        ${recentShow.venue}, ${recentShow.city}, ${recentShow.state}

Previous:     ${previous}
Venue:        ${prevShow.venue}, ${prevShow.city}, ${prevShow.state}

<strong>GAP:</strong>
Shows:        ${showGap} shows between
Days:         ${dayGap} days
Total Shows:  ${matchingShows.length} in ${input}`;
}

// Add click handlers for stats tables to navigate back to jam chart
document.addEventListener('click', e => {
  // Check for song name link in song history
  if (e.target.classList.contains('song-name-link')) {
    const norm = e.target.getAttribute('data-song-norm');
    showSongDetail(norm);
    return;
  }
  
  const target = e.target.closest('.clickable-filter');
  if (!target) return;
  
  // Check if we're in the stats page (but not song detail)
  const statsPage = document.getElementById('page-stats');
  const songDetailPane = document.getElementById('db-song-detail');
  
  if (statsPage.style.display !== 'none') {
    const text = target.textContent.trim();
    
    // If in song detail view, check if this is a date click
    if (songDetailPane.classList.contains('active') && target.closest('td') && target.closest('td').cellIndex === 0) {
      // This is a date in the song detail table
      const clickedRow = target.closest('tr');
      
      // Switch to jam chart page
      switchPageByName('jams');
      
      // Set search and filter
      document.getElementById('search-input').value = text;
      renderFilteredJams();
      
      // Highlight the matching row in jam chart
      setTimeout(() => {
        document.querySelectorAll('.jam-table tbody tr').forEach(row => {
          row.classList.remove('selected-row');
          const dateCell = row.children[0]?.textContent.trim();
          if (dateCell === text) {
            row.classList.add('selected-row');
            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        });
      }, 100);
    } else {
      // Regular click from other stats tabs
      switchPageByName('jams');
      document.getElementById('search-input').value = text;
      renderFilteredJams();
    }
  }
});

function showSongDetail(normSongName) {
  const song = dbSongs[normSongName];
  if (!song) {
    console.log("❌ Song not found in dbSongs:", normSongName);
    return;
  }
  
  console.log("🔄 showSongDetail called with:", normSongName);
  console.log("Song data:", song);
  
  currentSongDetail = { norm: normSongName, data: song };
  
  // Get unique dates for counting
  const uniqueDates = [...new Set(song.performances)];
  
  // Update header info
  document.getElementById('song-detail-title').textContent = song.name;
  document.getElementById('song-detail-count').textContent = song.performances.length;
  document.getElementById('song-detail-first').textContent = song.firstPlayed;
  document.getElementById('song-detail-last').textContent = song.lastPlayed;
  
  const lastIdx = dbDates.indexOf(song.lastPlayed);
  const currentGap = dbDates.length - 1 - lastIdx;
  document.getElementById('song-detail-gap').textContent = currentGap;
  
  // Clear the new song search input
  document.getElementById('song-detail-new-search').value = '';
  
  // Render performance table
  renderSongDetailTable();
  
  // Switch to song detail tab
  switchDbTab('song-detail');
}

function renderSongDetailTable() {
  if (!currentSongDetail) return;
  
  const tbody = document.getElementById('song-detail-tbody');
  tbody.innerHTML = '';
  
  const song = currentSongDetail.data;
  
  // Get unique dates sorted chronologically (oldest to newest)
const performanceDates = song.performances.map(p => typeof p === 'string' ? p : p.date);
const uniqueDates = [...new Set(performanceDates)].sort((a, b) => new Date(a) - new Date(b));  
  let performances = [];
  const seenPerformances = new Set();
  
  // Build performances with proper gap calculation
  uniqueDates.forEach((date, dateIndex) => {
    const show = dbShows[date];
    if (!show) return;
    
    const sets = show.sets || {};
    let occurrenceInDate = 0;
    
    Object.entries(sets).forEach(([setName, setContent]) => {
      const songs = parseDbSetlist(setContent);
      
      songs.forEach((songName, idx) => {
        let norm = normalizeSongName(songName);
        
        // SPECIAL HANDLING: Apply the same normalization as in processShowsDatabase
        if (norm.includes("to be young") || norm.includes("is to be high") || norm.includes("is to be sad")) {
          norm = "to be young is to be sad is to be high";
        }
        
        if (norm === currentSongDetail.norm) {
          const perfKey = `${date}-${setName}-${idx}`;
          
          if (!seenPerformances.has(perfKey)) {
            seenPerformances.add(perfKey);
            
            // Standardize set name
            let standardizedSetName = setName;
            if (setName.toLowerCase().includes('set1') || setName === '1') {
              standardizedSetName = 'Set 1';
            } else if (setName.toLowerCase().includes('set2') || setName === '2') {
              standardizedSetName = 'Set 2';
            } else if (setName.toLowerCase().includes('set3') || setName === '3') {
              standardizedSetName = 'Set 3';
            } else if (setName.toLowerCase().includes('encore')) {
              standardizedSetName = 'Encore';
            } else {
              standardizedSetName = setName.replace('set', 'Set ');
            }
            
            // Calculate gap
            let gap = '-';
            const isFirstOccurrence = occurrenceInDate === 0;
            
            if (isFirstOccurrence) {
              if (dateIndex === 0) {
                // First ever performance - calculate gap from start of database
                const currentDateIndex = dbDates.indexOf(date);
                gap = currentDateIndex;
              } else {
                // Subsequent performances - calculate gap from previous performance
                const currentDateIndex = dbDates.indexOf(date);
                const prevDateIndex = dbDates.indexOf(uniqueDates[dateIndex - 1]);
                gap = Math.max(0, currentDateIndex - prevDateIndex - 1);
              }
            }
            
            occurrenceInDate++;
            
            // Store chronological index for stable sorting
            const chronologicalIndex = dateIndex;
            
            performances.push({
              date,
              dateTimestamp: new Date(date).getTime(),
              chronologicalIndex,
              show,
              setName: standardizedSetName,
              position: idx,
              songBefore: idx > 0 ? songs[idx - 1].replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, '') : '-',
              songAfter: idx < songs.length - 1 ? songs[idx + 1].replace(/\s*\[\s*\d+[\d:]*\s*\]\s*/g, '') : '-',
              gap: gap,
              isFirstOccurrenceOfDate: isFirstOccurrence
            });
          }
        }
      });
    });
  });
  
  // Apply sorting
  const sort = dbSortState.songDetail;
  performances.sort((a, b) => {
    let result = 0;
    
    if (sort.column === 'date') {
      // Use chronological index for stable, predictable sorting
      result = a.chronologicalIndex - b.chronologicalIndex;
      if (result === 0) {
        const setOrder = {'Set 1': 1, 'Set 2': 2, 'Set 3': 3, 'Encore': 4};
        result = (setOrder[a.setName] || 5) - (setOrder[b.setName] || 5);
        if (result === 0) {
          result = a.position - b.position;
        }
      }
    } else if (sort.column === 'venue') {
      const va = (a.show.venue || '').toLowerCase();
      const vb = (b.show.venue || '').toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    } else if (sort.column === 'gap') {
      const va = (a.gap === '-' || a.gap === '') ? -1 : parseInt(a.gap);
      const vb = (b.gap === '-' || b.gap === '') ? -1 : parseInt(b.gap);
      result = va - vb;
    } else if (sort.column === 'set') {
      const setOrder = {'Set 1': 1, 'Set 2': 2, 'Set 3': 3, 'Encore': 4};
      result = (setOrder[a.setName] || 5) - (setOrder[b.setName] || 5);
      if (result === 0) {
        result = a.position - b.position;
      }
    } else if (sort.column === 'songBefore') {
      const va = a.songBefore.toLowerCase();
      const vb = b.songBefore.toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    } else if (sort.column === 'songAfter') {
      const va = a.songAfter.toLowerCase();
      const vb = b.songAfter.toLowerCase();
      result = va < vb ? -1 : va > vb ? 1 : 0;
    }
    
    return sort.direction === 'asc' ? result : -result;
  });
  
  // IMPROVED JAM MATCHING LOGIC
  const jamsForSong = allJams.filter(j => {
    const jamNorm = normalizeSongName(j.song);
    const dbNorm = currentSongDetail.norm;
    
    // Direct match
    if (jamNorm === dbNorm) return true;
    
    // Special case for "To Be Young" variations
    if ((jamNorm.includes("to be young") || jamNorm.includes("is to be high") || jamNorm.includes("is to be sad")) &&
        (dbNorm.includes("to be young") || dbNorm.includes("is to be high") || dbNorm.includes("is to be sad"))) {
      return true;
    }
    
    // Fuzzy matching for other songs - check if one contains the other
    if (jamNorm.includes(dbNorm) || dbNorm.includes(jamNorm)) {
      return true;
    }
    
    return false;
  });
  
  // Render each performance
  performances.forEach(perf => {
    const jamEntry = jamsForSong.find(j => {
      const jamDate = j.date;
      const formattedJamDate = formatDateForDisplay(jamDate);
      
      // Try multiple date formats for matching
      return jamDate === perf.date || 
             formattedJamDate === perf.date ||
             formatDateForDisplay(perf.date) === jamDate ||
             formatDateForDisplay(perf.date) === formattedJamDate;
    });
    
    const isHighlighted = jamEntry?.highlighted;
    const notes = jamEntry?.notes || '-';
    
    const tr = document.createElement('tr');
    if (isHighlighted) tr.classList.add('highlighted-row');
    
    const dateText = perf.date;
    const venueText = perf.show.venue || 'Unknown';
    
    tr.innerHTML = `
      <td><span class="clickable-filter" style="${isHighlighted ? 'font-weight:bold;' : ''}">${dateText}</span></td>
      <td><span class="clickable-filter">${venueText}</span></td>
      <td>${perf.isFirstOccurrenceOfDate ? perf.gap : ''}</td>
      <td>${perf.setName}</td>
      <td>${perf.songBefore}</td>
      <td>${perf.songAfter}</td>
      <td>${notes}</td>
    `;
    
    tbody.appendChild(tr);
  });
  
  if (performances.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;padding:2rem;color:var(--muted-color);">No performances found in setlists for this song</td></tr>';
  }
}

function sortSongDetail(column) {
  if (dbSortState.songDetail.column === column) {
    dbSortState.songDetail.direction = dbSortState.songDetail.direction === 'asc' ? 'desc' : 'asc';
  } else {
    dbSortState.songDetail.column = column;
    dbSortState.songDetail.direction = 'asc';
  }
  
  document.querySelectorAll('#db-song-detail thead th span').forEach(span => span.textContent = '');
  
  const indicator = document.getElementById('song-detail-' + column + '-sort');
  if (indicator) indicator.textContent = dbSortState.songDetail.direction === 'asc' ? '▲' : '▼';
  
  renderSongDetailTable();
}

function filterSongDetail() {
  const search = document.getElementById('song-detail-search').value.toLowerCase();
  const allRows = document.querySelectorAll('#song-detail-tbody tr');
  
  allRows.forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(search) ? '' : 'none';
  });
}

function searchNewSongFromDetail() {
  const searchValue = document.getElementById('song-detail-new-search').value.trim();
  if (!searchValue) return;
  
  // Find the song in the database
  const normSearch = normalizeSongName(searchValue);
  const song = dbSongs[normSearch];
  
  if (song) {
    // Show the song detail for the new song
    showSongDetail(normSearch);
  } else {
    // If not found, search in the main song list and switch to song history
    document.getElementById('db-song-search').value = searchValue;
    switchDbTab('songs');
    filterDbSongs();
  }
}

function switchPageByName(page) {
  document.querySelectorAll('.page-tab').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.page-content').forEach(pane => pane.style.display = 'none');
  
  document.querySelector(`.page-tab[onclick="switchPage('${page}')"]`).classList.add('active');
  document.getElementById('page-' + page).style.display = 'block';
}

function switchDbTab(tab) {
  document.querySelectorAll('.tab-button:not(.page-tab)').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
  
  if (event && event.target) {
    event.target.classList.add('active');
  } else {
    document.querySelector(`.tab-button[onclick*="${tab}"]`).classList.add('active');
  }
  document.getElementById('db-' + tab).classList.add('active');
}

document.addEventListener('DOMContentLoaded', function() {
  loadShowsDatabase();
});
</script>
</body>
</html>
